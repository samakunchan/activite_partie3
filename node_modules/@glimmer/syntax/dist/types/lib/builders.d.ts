import * as AST from './types/nodes';
import { Option } from '@glimmer/interfaces';
export declare type BuilderPath = string | AST.PathExpression;
export declare const SYNTHETIC: AST.SourceLocation;
declare const _default: {
    mustache: (path: string | AST.PathExpression | AST.StringLiteral | AST.BooleanLiteral | AST.NumberLiteral | AST.UndefinedLiteral | AST.NullLiteral, params?: AST.Expression[] | undefined, hash?: AST.Hash | undefined, raw?: boolean | undefined, loc?: AST.SourceLocation | undefined) => AST.MustacheStatement;
    block: (path: BuilderPath, params: Option<AST.Expression[]>, hash: Option<AST.Hash>, program: AST.Program, inverse?: AST.Program | null | undefined, loc?: AST.SourceLocation | undefined) => AST.BlockStatement;
    partial: (name: AST.PathExpression, params?: AST.Expression[] | undefined, hash?: AST.Hash | undefined, indent?: string | undefined, loc?: AST.SourceLocation | undefined) => AST.PartialStatement;
    comment: (value: string, loc?: AST.SourceLocation | undefined) => AST.CommentStatement;
    mustacheComment: (value: string, loc?: AST.SourceLocation | undefined) => AST.MustacheCommentStatement;
    element: {
        (tag: string, attributes?: AST.AttrNode[] | undefined, modifiers?: AST.ElementModifierStatement[] | undefined, children?: AST.Statement[] | undefined, loc?: AST.SourceLocation | undefined): AST.ElementNode;
        (tag: string, attributes?: AST.AttrNode[] | undefined, modifiers?: AST.ElementModifierStatement[] | undefined, children?: AST.Statement[] | undefined, comments?: AST.MustacheCommentStatement[] | undefined, loc?: AST.SourceLocation | undefined): AST.ElementNode;
    };
    elementModifier: (path: BuilderPath, params?: AST.Expression[] | undefined, hash?: AST.Hash | undefined, loc?: AST.SourceLocation | null | undefined) => AST.ElementModifierStatement;
    attr: (name: string, value: AST.MustacheStatement | AST.TextNode | AST.ConcatStatement, loc?: AST.SourceLocation | undefined) => AST.AttrNode;
    text: (chars?: string | undefined, loc?: AST.SourceLocation | undefined) => AST.TextNode;
    sexpr: (path: AST.PathExpression, params?: AST.Expression[] | undefined, hash?: AST.Hash | undefined, loc?: AST.SourceLocation | undefined) => AST.SubExpression;
    path: (original: BuilderPath, loc?: AST.SourceLocation | undefined) => AST.PathExpression;
    concat: (parts: (AST.MustacheStatement | AST.TextNode)[], loc?: AST.SourceLocation | undefined) => AST.ConcatStatement;
    hash: (pairs?: AST.HashPair[] | undefined, loc?: AST.SourceLocation | undefined) => AST.Hash;
    pair: (key: string, value: AST.Expression, loc?: AST.SourceLocation | undefined) => AST.HashPair;
    literal: <T extends AST.Literal>(type: T["type"], value: T["value"], loc?: AST.SourceLocation | undefined) => AST.Literal;
    program: (body?: AST.Statement[] | undefined, blockParams?: string[] | undefined, loc?: AST.SourceLocation | undefined) => AST.Program;
    loc: {
        (loc: Option<AST.SourceLocation>): AST.SourceLocation;
        (startLine: number, startColumn: number, endLine?: number | undefined, endColumn?: number | undefined, source?: string | undefined): AST.SourceLocation;
    };
    pos: (line: number, column: number) => {
        line: number;
        column: number;
    };
    string: (value: string | number | boolean | null | undefined) => AST.Literal;
    boolean: (value: string | number | boolean | null | undefined) => AST.Literal;
    number: (value: string | number | boolean | null | undefined) => AST.Literal;
    undefined(): AST.Literal;
    null(): AST.Literal;
};
export default _default;

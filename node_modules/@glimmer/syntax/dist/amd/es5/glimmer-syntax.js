define('@glimmer/syntax', ['exports', 'simple-html-tokenizer', '@glimmer/util', 'handlebars'], function (exports, simpleHtmlTokenizer, util, handlebars) { 'use strict';

function isCall(node) {
    return node.type === 'SubExpression' || node.type === 'MustacheStatement' && node.path.type === 'PathExpression';
}
function isLiteral(input) {
    return !!(typeof input === 'object' && input.type.match(/Literal$/));
}


var nodes = Object.freeze({
	isCall: isCall,
	isLiteral: isLiteral
});

function buildMustache(path, params, hash, raw, loc) {
    if (!isLiteral(path)) {
        path = buildPath(path);
    }
    return {
        type: "MustacheStatement",
        path: path,
        params: params || [],
        hash: hash || buildHash([]),
        escaped: !raw,
        loc: buildLoc(loc || null)
    };
}
function buildBlock(path, params, hash, program, inverse, loc) {
    return {
        type: "BlockStatement",
        path: buildPath(path),
        params: params || [],
        hash: hash || buildHash([]),
        program: program || null,
        inverse: inverse || null,
        loc: buildLoc(loc || null)
    };
}
function buildElementModifier(path, params, hash, loc) {
    return {
        type: "ElementModifierStatement",
        path: buildPath(path),
        params: params || [],
        hash: hash || buildHash([]),
        loc: buildLoc(loc || null)
    };
}
function buildPartial(name, params, hash, indent, loc) {
    return {
        type: "PartialStatement",
        name: name,
        params: params || [],
        hash: hash || buildHash([]),
        indent: indent || '',
        strip: { open: false, close: false },
        loc: buildLoc(loc || null)
    };
}
function buildComment(value, loc) {
    return {
        type: "CommentStatement",
        value: value,
        loc: buildLoc(loc || null)
    };
}
function buildMustacheComment(value, loc) {
    return {
        type: "MustacheCommentStatement",
        value: value,
        loc: buildLoc(loc || null)
    };
}
function buildConcat(parts, loc) {
    return {
        type: "ConcatStatement",
        parts: parts || [],
        loc: buildLoc(loc || null)
    };
}
function buildElement(tag, attributes, modifiers, children, comments, loc) {
    // this is used for backwards compat prior to `comments` being added to the AST
    if (!Array.isArray(comments)) {
        loc = comments;
        comments = [];
    }
    return {
        type: "ElementNode",
        tag: tag || "",
        attributes: attributes || [],
        blockParams: [],
        modifiers: modifiers || [],
        comments: comments || [],
        children: children || [],
        loc: buildLoc(loc || null)
    };
}
function buildAttr(name, value, loc) {
    return {
        type: "AttrNode",
        name: name,
        value: value,
        loc: buildLoc(loc || null)
    };
}
function buildText(chars, loc) {
    return {
        type: "TextNode",
        chars: chars || "",
        loc: buildLoc(loc || null)
    };
}
// Expressions
function buildSexpr(path, params, hash, loc) {
    return {
        type: "SubExpression",
        path: buildPath(path),
        params: params || [],
        hash: hash || buildHash([]),
        loc: buildLoc(loc || null)
    };
}
function buildPath(original, loc) {
    if (typeof original !== 'string') return original;
    var parts = original.split('.');
    var thisHead = false;
    if (parts[0] === 'this') {
        thisHead = true;
        parts = parts.slice(1);
    }
    return {
        type: "PathExpression",
        original: original,
        this: thisHead,
        parts: parts,
        data: false,
        loc: buildLoc(loc || null)
    };
}
function buildLiteral(type, value, loc) {
    return {
        type: type,
        value: value,
        original: value,
        loc: buildLoc(loc || null)
    };
}
// Miscellaneous
function buildHash(pairs, loc) {
    return {
        type: "Hash",
        pairs: pairs || [],
        loc: buildLoc(loc || null)
    };
}
function buildPair(key, value, loc) {
    return {
        type: "HashPair",
        key: key,
        value: value,
        loc: buildLoc(loc || null)
    };
}
function buildProgram(body, blockParams, loc) {
    return {
        type: "Program",
        body: body || [],
        blockParams: blockParams || [],
        loc: buildLoc(loc || null)
    };
}
function buildSource(source) {
    return source || null;
}
function buildPosition(line, column) {
    return {
        line: line,
        column: column
    };
}
var SYNTHETIC = { source: '(synthetic)', start: { line: 1, column: 0 }, end: { line: 1, column: 0 } };
function buildLoc() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
    }

    if (args.length === 1) {
        var loc = args[0];
        if (loc && typeof loc === 'object') {
            return {
                source: buildSource(loc.source),
                start: buildPosition(loc.start.line, loc.start.column),
                end: buildPosition(loc.end.line, loc.end.column)
            };
        } else {
            return SYNTHETIC;
        }
    } else {
        var startLine = args[0],
            startColumn = args[1],
            endLine = args[2],
            endColumn = args[3],
            source = args[4];

        return {
            source: buildSource(source),
            start: buildPosition(startLine, startColumn),
            end: buildPosition(endLine, endColumn)
        };
    }
}
var b = {
    mustache: buildMustache,
    block: buildBlock,
    partial: buildPartial,
    comment: buildComment,
    mustacheComment: buildMustacheComment,
    element: buildElement,
    elementModifier: buildElementModifier,
    attr: buildAttr,
    text: buildText,
    sexpr: buildSexpr,
    path: buildPath,
    concat: buildConcat,
    hash: buildHash,
    pair: buildPair,
    literal: buildLiteral,
    program: buildProgram,
    loc: buildLoc,
    pos: buildPosition,
    string: literal('StringLiteral'),
    boolean: literal('BooleanLiteral'),
    number: literal('NumberLiteral'),
    undefined: function (_undefined) {
        function undefined() {
            return _undefined.apply(this, arguments);
        }

        undefined.toString = function () {
            return _undefined.toString();
        };

        return undefined;
    }(function () {
        return buildLiteral('UndefinedLiteral', undefined);
    }),
    null: function _null() {
        return buildLiteral('NullLiteral', null);
    }
};
function literal(type) {
    return function (value) {
        return buildLiteral(type, value);
    };
}

/**
 * Subclass of `Error` with additional information
 * about location of incorrect markup.
 */
var SyntaxError = function () {
    SyntaxError.prototype = Object.create(Error.prototype);
    SyntaxError.prototype.constructor = SyntaxError;
    function SyntaxError(message, location) {
        var error = Error.call(this, message);
        this.message = message;
        this.stack = error.stack;
        this.location = location;
    }
    return SyntaxError;
}();

// Regex to validate the identifier for block parameters.
// Based on the ID validation regex in Handlebars.
var ID_INVERSE_PATTERN = /[!"#%-,\.\/;->@\[-\^`\{-~]/;
// Checks the element's attributes to see if it uses block params.
// If it does, registers the block params with the program and
// removes the corresponding attributes from the element.
function parseElementBlockParams(element) {
    var params = parseBlockParams(element);
    if (params) element.blockParams = params;
}
function parseBlockParams(element) {
    var l = element.attributes.length;
    var attrNames = [];
    for (var i = 0; i < l; i++) {
        attrNames.push(element.attributes[i].name);
    }
    var asIndex = attrNames.indexOf('as');
    if (asIndex !== -1 && l > asIndex && attrNames[asIndex + 1].charAt(0) === '|') {
        // Some basic validation, since we're doing the parsing ourselves
        var paramsString = attrNames.slice(asIndex).join(' ');
        if (paramsString.charAt(paramsString.length - 1) !== '|' || paramsString.match(/\|/g).length !== 2) {
            throw new SyntaxError('Invalid block parameters syntax: \'' + paramsString + '\'', element.loc);
        }
        var params = [];
        for (var _i = asIndex + 1; _i < l; _i++) {
            var param = attrNames[_i].replace(/\|/g, '');
            if (param !== '') {
                if (ID_INVERSE_PATTERN.test(param)) {
                    throw new SyntaxError('Invalid identifier for block parameters: \'' + param + '\' in \'' + paramsString + '\'', element.loc);
                }
                params.push(param);
            }
        }
        if (params.length === 0) {
            throw new SyntaxError('Cannot use zero block parameters: \'' + paramsString + '\'', element.loc);
        }
        element.attributes = element.attributes.slice(0, asIndex);
        return params;
    }
    return null;
}
function childrenFor(node) {
    switch (node.type) {
        case 'Program':
            return node.body;
        case 'ElementNode':
            return node.children;
    }
}
function appendChild(parent, node) {
    childrenFor(parent).push(node);
}
function isLiteral$1(path) {
    return path.type === 'StringLiteral' || path.type === 'BooleanLiteral' || path.type === 'NumberLiteral' || path.type === 'NullLiteral' || path.type === 'UndefinedLiteral';
}
function printLiteral(literal) {
    if (literal.type === 'UndefinedLiteral') {
        return 'undefined';
    } else {
        return JSON.stringify(literal.value);
    }
}

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var entityParser = new simpleHtmlTokenizer.EntityParser(simpleHtmlTokenizer.HTML5NamedCharRefs);
var Parser = function () {
    function Parser(source) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck$2(this, Parser);

        this.elementStack = [];
        this.currentAttribute = null;
        this.currentNode = null;
        this.tokenizer = new simpleHtmlTokenizer.EventedTokenizer(this, entityParser);
        this.options = options;
        this.tokenizer.states.tagOpen = function () {
            var char = this.consume();
            if (char === "!") {
                this['state'] = 'markupDeclaration';
            } else if (char === "/") {
                this['state'] = 'endTagOpen';
            } else if (/[A-Za-z]/.test(char)) {
                this['state'] = 'tagName';
                this['delegate'].beginStartTag();
                this['delegate'].appendToTagName(char);
            }
        };
        this.tokenizer.states.endTagOpen = function () {
            var char = this.consume();
            if (/[A-Za-z]/.test(char)) {
                this['state'] = 'tagName';
                this['delegate'].beginEndTag();
                this['delegate'].appendToTagName(char);
            }
        };
        this.source = source.split(/(?:\r\n?|\n)/g);
    }

    Parser.prototype.acceptNode = function acceptNode(node) {
        return this[node.type](node);
    };

    Parser.prototype.currentElement = function currentElement() {
        return this.elementStack[this.elementStack.length - 1];
    };

    Parser.prototype.sourceForNode = function sourceForNode(node, endNode) {
        var firstLine = node.loc.start.line - 1;
        var currentLine = firstLine - 1;
        var firstColumn = node.loc.start.column;
        var string = [];
        var line = void 0;
        var lastLine = void 0;
        var lastColumn = void 0;
        if (endNode) {
            lastLine = endNode.loc.end.line - 1;
            lastColumn = endNode.loc.end.column;
        } else {
            lastLine = node.loc.end.line - 1;
            lastColumn = node.loc.end.column;
        }
        while (currentLine < lastLine) {
            currentLine++;
            line = this.source[currentLine];
            if (currentLine === firstLine) {
                if (firstLine === lastLine) {
                    string.push(line.slice(firstColumn, lastColumn));
                } else {
                    string.push(line.slice(firstColumn));
                }
            } else if (currentLine === lastLine) {
                string.push(line.slice(0, lastColumn));
            } else {
                string.push(line);
            }
        }
        return string.join('\n');
    };

    _createClass(Parser, [{
        key: "currentAttr",
        get: function get() {
            return this.currentAttribute;
        }
    }, {
        key: "currentTag",
        get: function get() {
            var node = this.currentNode;
            return node;
        }
    }, {
        key: "currentStartTag",
        get: function get() {
            var node = this.currentNode;
            return node;
        }
    }, {
        key: "currentEndTag",
        get: function get() {
            var node = this.currentNode;
            return node;
        }
    }, {
        key: "currentComment",
        get: function get() {
            var node = this.currentNode;
            return node;
        }
    }, {
        key: "currentData",
        get: function get() {
            var node = this.currentNode;
            return node;
        }
    }]);

    return Parser;
}();

function _defaults$1(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$1(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$1(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults$1(subClass, superClass); }

var HandlebarsNodeVisitors = function (_Parser) {
    _inherits$1(HandlebarsNodeVisitors, _Parser);

    function HandlebarsNodeVisitors() {
        _classCallCheck$1(this, HandlebarsNodeVisitors);

        var _this = _possibleConstructorReturn$1(this, _Parser.apply(this, arguments));

        _this.cursorCount = 0;
        return _this;
    }

    HandlebarsNodeVisitors.prototype.cursor = function cursor() {
        return "%cursor:" + this.cursorCount++ + "%";
    };

    HandlebarsNodeVisitors.prototype.Program = function Program(program) {
        var body = [];
        this.cursorCount = 0;
        var node = b.program(body, program.blockParams, program.loc);
        var i = void 0,
            l = program.body.length;
        this.elementStack.push(node);
        if (l === 0) {
            return this.elementStack.pop();
        }
        for (i = 0; i < l; i++) {
            this.acceptNode(program.body[i]);
        }
        // Ensure that that the element stack is balanced properly.
        var poppedNode = this.elementStack.pop();
        if (poppedNode !== node) {
            var elementNode = poppedNode;
            throw new SyntaxError("Unclosed element `" + elementNode.tag + "` (on line " + elementNode.loc.start.line + ").", elementNode.loc);
        }
        return node;
    };

    HandlebarsNodeVisitors.prototype.BlockStatement = function BlockStatement(block) {
        if (this.tokenizer['state'] === 'comment') {
            this.appendToCommentData(this.sourceForNode(block));
            return;
        }
        if (this.tokenizer['state'] !== 'comment' && this.tokenizer['state'] !== 'data' && this.tokenizer['state'] !== 'beforeData') {
            throw new SyntaxError("A block may only be used inside an HTML element or another block.", block.loc);
        }

        var _acceptCallNodes = acceptCallNodes(this, block),
            path = _acceptCallNodes.path,
            params = _acceptCallNodes.params,
            hash = _acceptCallNodes.hash;

        var program = this.Program(block.program);
        var inverse = block.inverse ? this.Program(block.inverse) : null;
        if (path.original === 'in-element') {
            hash = addInElementHash(this.cursor(), hash, block.loc);
        }
        var node = b.block(path, params, hash, program, inverse, block.loc);
        var parentProgram = this.currentElement();
        appendChild(parentProgram, node);
    };

    HandlebarsNodeVisitors.prototype.MustacheStatement = function MustacheStatement(rawMustache) {
        var tokenizer = this.tokenizer;

        if (tokenizer['state'] === 'comment') {
            this.appendToCommentData(this.sourceForNode(rawMustache));
            return;
        }
        var mustache = void 0;
        var escaped = rawMustache.escaped,
            loc = rawMustache.loc;

        if (rawMustache.path.type.match(/Literal$/)) {
            mustache = {
                type: 'MustacheStatement',
                path: this.acceptNode(rawMustache.path),
                params: [],
                hash: b.hash(),
                escaped: escaped,
                loc: loc
            };
        } else {
            var _acceptCallNodes2 = acceptCallNodes(this, rawMustache),
                path = _acceptCallNodes2.path,
                params = _acceptCallNodes2.params,
                hash = _acceptCallNodes2.hash;

            mustache = b.mustache(path, params, hash, !escaped, loc);
        }
        switch (tokenizer['state']) {
            // Tag helpers
            case "tagName":
                addElementModifier(this.currentStartTag, mustache);
                tokenizer['state'] = "beforeAttributeName";
                break;
            case "beforeAttributeName":
                addElementModifier(this.currentStartTag, mustache);
                break;
            case "attributeName":
            case "afterAttributeName":
                this.beginAttributeValue(false);
                this.finishAttributeValue();
                addElementModifier(this.currentStartTag, mustache);
                tokenizer['state'] = "beforeAttributeName";
                break;
            case "afterAttributeValueQuoted":
                addElementModifier(this.currentStartTag, mustache);
                tokenizer['state'] = "beforeAttributeName";
                break;
            // Attribute values
            case "beforeAttributeValue":
                this.beginAttributeValue(false);
                appendDynamicAttributeValuePart(this.currentAttribute, mustache);
                tokenizer['state'] = 'attributeValueUnquoted';
                break;
            case "attributeValueDoubleQuoted":
            case "attributeValueSingleQuoted":
            case "attributeValueUnquoted":
                appendDynamicAttributeValuePart(this.currentAttribute, mustache);
                break;
            // TODO: Only append child when the tokenizer state makes
            // sense to do so, otherwise throw an error.
            default:
                appendChild(this.currentElement(), mustache);
        }
        return mustache;
    };

    HandlebarsNodeVisitors.prototype.ContentStatement = function ContentStatement(content) {
        updateTokenizerLocation(this.tokenizer, content);
        this.tokenizer.tokenizePart(content.value);
        this.tokenizer.flushData();
    };

    HandlebarsNodeVisitors.prototype.CommentStatement = function CommentStatement(rawComment) {
        var tokenizer = this.tokenizer;

        if (tokenizer['state'] === 'comment') {
            this.appendToCommentData(this.sourceForNode(rawComment));
            return null;
        }
        var value = rawComment.value,
            loc = rawComment.loc;

        var comment = b.mustacheComment(value, loc);
        switch (tokenizer['state']) {
            case "beforeAttributeName":
                this.currentStartTag.comments.push(comment);
                break;
            case 'beforeData':
            case 'data':
                appendChild(this.currentElement(), comment);
                break;
            default:
                throw new SyntaxError("Using a Handlebars comment when in the `" + tokenizer['state'] + "` state is not supported: \"" + comment.value + "\" on line " + loc.start.line + ":" + loc.start.column, rawComment.loc);
        }
        return comment;
    };

    HandlebarsNodeVisitors.prototype.PartialStatement = function PartialStatement(partial) {
        var loc = partial.loc;

        throw new SyntaxError("Handlebars partials are not supported: \"" + this.sourceForNode(partial, partial.name) + "\" at L" + loc.start.line + ":C" + loc.start.column, partial.loc);
    };

    HandlebarsNodeVisitors.prototype.PartialBlockStatement = function PartialBlockStatement(partialBlock) {
        var loc = partialBlock.loc;

        throw new SyntaxError("Handlebars partial blocks are not supported: \"" + this.sourceForNode(partialBlock, partialBlock.name) + "\" at L" + loc.start.line + ":C" + loc.start.column, partialBlock.loc);
    };

    HandlebarsNodeVisitors.prototype.Decorator = function Decorator(decorator) {
        var loc = decorator.loc;

        throw new SyntaxError("Handlebars decorators are not supported: \"" + this.sourceForNode(decorator, decorator.path) + "\" at L" + loc.start.line + ":C" + loc.start.column, decorator.loc);
    };

    HandlebarsNodeVisitors.prototype.DecoratorBlock = function DecoratorBlock(decoratorBlock) {
        var loc = decoratorBlock.loc;

        throw new SyntaxError("Handlebars decorator blocks are not supported: \"" + this.sourceForNode(decoratorBlock, decoratorBlock.path) + "\" at L" + loc.start.line + ":C" + loc.start.column, decoratorBlock.loc);
    };

    HandlebarsNodeVisitors.prototype.SubExpression = function SubExpression(sexpr) {
        var _acceptCallNodes3 = acceptCallNodes(this, sexpr),
            path = _acceptCallNodes3.path,
            params = _acceptCallNodes3.params,
            hash = _acceptCallNodes3.hash;

        return b.sexpr(path, params, hash, sexpr.loc);
    };

    HandlebarsNodeVisitors.prototype.PathExpression = function PathExpression(path) {
        var original = path.original,
            loc = path.loc;

        var parts = void 0;
        if (original.indexOf('/') !== -1) {
            if (original.slice(0, 2) === './') {
                throw new SyntaxError("Using \"./\" is not supported in Glimmer and unnecessary: \"" + path.original + "\" on line " + loc.start.line + ".", path.loc);
            }
            if (original.slice(0, 3) === '../') {
                throw new SyntaxError("Changing context using \"../\" is not supported in Glimmer: \"" + path.original + "\" on line " + loc.start.line + ".", path.loc);
            }
            if (original.indexOf('.') !== -1) {
                throw new SyntaxError("Mixing '.' and '/' in paths is not supported in Glimmer; use only '.' to separate property paths: \"" + path.original + "\" on line " + loc.start.line + ".", path.loc);
            }
            parts = [path.parts.join('/')];
        } else {
            parts = path.parts;
        }
        var thisHead = false;
        // This is to fix a bug in the Handlebars AST where the path expressions in
        // `{{this.foo}}` (and similarly `{{foo-bar this.foo named=this.foo}}` etc)
        // are simply turned into `{{foo}}`. The fix is to push it back onto the
        // parts array and let the runtime see the difference. However, we cannot
        // simply use the string `this` as it means literally the property called
        // "this" in the current context (it can be expressed in the syntax as
        // `{{[this]}}`, where the square bracket are generally for this kind of
        // escaping – such as `{{foo.["bar.baz"]}}` would mean lookup a property
        // named literally "bar.baz" on `this.foo`). By convention, we use `null`
        // for this purpose.
        if (original.match(/^this(\..+)?$/)) {
            thisHead = true;
        }
        return {
            type: 'PathExpression',
            original: path.original,
            this: thisHead,
            parts: parts,
            data: path.data,
            loc: path.loc
        };
    };

    HandlebarsNodeVisitors.prototype.Hash = function Hash(hash) {
        var pairs = [];
        for (var i = 0; i < hash.pairs.length; i++) {
            var pair = hash.pairs[i];
            pairs.push(b.pair(pair.key, this.acceptNode(pair.value), pair.loc));
        }
        return b.hash(pairs, hash.loc);
    };

    HandlebarsNodeVisitors.prototype.StringLiteral = function StringLiteral(string) {
        return b.literal('StringLiteral', string.value, string.loc);
    };

    HandlebarsNodeVisitors.prototype.BooleanLiteral = function BooleanLiteral(boolean) {
        return b.literal('BooleanLiteral', boolean.value, boolean.loc);
    };

    HandlebarsNodeVisitors.prototype.NumberLiteral = function NumberLiteral(number) {
        return b.literal('NumberLiteral', number.value, number.loc);
    };

    HandlebarsNodeVisitors.prototype.UndefinedLiteral = function UndefinedLiteral(undef) {
        return b.literal('UndefinedLiteral', undefined, undef.loc);
    };

    HandlebarsNodeVisitors.prototype.NullLiteral = function NullLiteral(nul) {
        return b.literal('NullLiteral', null, nul.loc);
    };

    return HandlebarsNodeVisitors;
}(Parser);
function calculateRightStrippedOffsets(original, value) {
    if (value === '') {
        // if it is empty, just return the count of newlines
        // in original
        return {
            lines: original.split("\n").length - 1,
            columns: 0
        };
    }
    // otherwise, return the number of newlines prior to
    // `value`
    var difference = original.split(value)[0];
    var lines = difference.split(/\n/);
    var lineCount = lines.length - 1;
    return {
        lines: lineCount,
        columns: lines[lineCount].length
    };
}
function updateTokenizerLocation(tokenizer, content) {
    var line = content.loc.start.line;
    var column = content.loc.start.column;
    var offsets = calculateRightStrippedOffsets(content.original, content.value);
    line = line + offsets.lines;
    if (offsets.lines) {
        column = offsets.columns;
    } else {
        column = column + offsets.columns;
    }
    tokenizer.line = line;
    tokenizer.column = column;
}
function acceptCallNodes(compiler, node) {
    var path = compiler.PathExpression(node.path);
    var params = node.params ? node.params.map(function (e) {
        return compiler.acceptNode(e);
    }) : [];
    var hash = node.hash ? compiler.Hash(node.hash) : b.hash();
    return { path: path, params: params, hash: hash };
}
function addElementModifier(element, mustache) {
    var path = mustache.path,
        params = mustache.params,
        hash = mustache.hash,
        loc = mustache.loc;

    if (isLiteral$1(path)) {
        var _modifier = "{{" + printLiteral(path) + "}}";
        var tag = "<" + element.name + " ... " + _modifier + " ...";
        throw new SyntaxError("In " + tag + ", " + _modifier + " is not a valid modifier: \"" + path.original + "\" on line " + (loc && loc.start.line) + ".", mustache.loc);
    }
    var modifier = b.elementModifier(path, params, hash, loc);
    element.modifiers.push(modifier);
}
function addInElementHash(cursor, hash, loc) {
    var hasNextSibling = false;
    hash.pairs.forEach(function (pair) {
        if (pair.key === 'guid') {
            throw new SyntaxError('Cannot pass `guid` from user space', loc);
        }
        if (pair.key === 'nextSibling') {
            hasNextSibling = true;
        }
    });
    var guid = b.literal('StringLiteral', cursor);
    var guidPair = b.pair('guid', guid);
    hash.pairs.unshift(guidPair);
    if (!hasNextSibling) {
        var nullLiteral = b.literal('NullLiteral', null);
        var nextSibling = b.pair('nextSibling', nullLiteral);
        hash.pairs.push(nextSibling);
    }
    return hash;
}
function appendDynamicAttributeValuePart(attribute, part) {
    attribute.isDynamic = true;
    attribute.parts.push(part);
}

var visitorKeys = {
    Program: ['body'],
    MustacheStatement: ['path', 'params', 'hash'],
    BlockStatement: ['path', 'params', 'hash', 'program', 'inverse'],
    ElementModifierStatement: ['path', 'params', 'hash'],
    PartialStatement: ['name', 'params', 'hash'],
    CommentStatement: [],
    MustacheCommentStatement: [],
    ElementNode: ['attributes', 'modifiers', 'children', 'comments'],
    AttrNode: ['value'],
    TextNode: [],
    ConcatStatement: ['parts'],
    SubExpression: ['path', 'params', 'hash'],
    PathExpression: [],
    StringLiteral: [],
    BooleanLiteral: [],
    NumberLiteral: [],
    NullLiteral: [],
    UndefinedLiteral: [],
    Hash: ['pairs'],
    HashPair: ['value']
};

var TraversalError = function () {
    TraversalError.prototype = Object.create(Error.prototype);
    TraversalError.prototype.constructor = TraversalError;
    function TraversalError(message, node, parent, key) {
        var error = Error.call(this, message);
        this.key = key;
        this.message = message;
        this.node = node;
        this.parent = parent;
        this.stack = error.stack;
    }
    return TraversalError;
}();
function cannotRemoveNode(node, parent, key) {
    return new TraversalError("Cannot remove a node unless it is part of an array", node, parent, key);
}
function cannotReplaceNode(node, parent, key) {
    return new TraversalError("Cannot replace a node with multiple nodes unless it is part of an array", node, parent, key);
}
function cannotReplaceOrRemoveInKeyHandlerYet(node, key) {
    return new TraversalError("Replacing and removing in key handlers is not yet supported.", node, null, key);
}

function visitNode(visitor, node) {
    var handler = visitor[node.type] || visitor.All || null;
    var result = void 0;
    if (handler && handler['enter']) {
        result = handler['enter'].call(null, node);
    }
    if (result !== undefined && result !== null) {
        if (JSON.stringify(node) === JSON.stringify(result)) {
            result = undefined;
        } else if (Array.isArray(result)) {
            return visitArray(visitor, result) || result;
        } else {
            return visitNode(visitor, result) || result;
        }
    }
    if (result === undefined) {
        var keys = visitorKeys[node.type];
        for (var i = 0; i < keys.length; i++) {
            visitKey(visitor, handler, node, keys[i]);
        }
        if (handler && handler['exit']) {
            result = handler['exit'].call(null, node);
        }
    }
    return result;
}
function visitKey(visitor, handler, node, key) {
    var value = node[key];
    if (!value) {
        return;
    }
    var keyHandler = handler && (handler.keys[key] || handler.keys.All);
    var result = void 0;
    if (keyHandler && keyHandler.enter) {
        result = keyHandler.enter.call(null, node, key);
        if (result !== undefined) {
            throw cannotReplaceOrRemoveInKeyHandlerYet(node, key);
        }
    }
    if (Array.isArray(value)) {
        visitArray(visitor, value);
    } else {
        var _result = visitNode(visitor, value);
        if (_result !== undefined) {
            assignKey(node, key, _result);
        }
    }
    if (keyHandler && keyHandler.exit) {
        result = keyHandler.exit.call(null, node, key);
        if (result !== undefined) {
            throw cannotReplaceOrRemoveInKeyHandlerYet(node, key);
        }
    }
}
function visitArray(visitor, array) {
    for (var i = 0; i < array.length; i++) {
        var result = visitNode(visitor, array[i]);
        if (result !== undefined) {
            i += spliceArray(array, i, result) - 1;
        }
    }
}
function assignKey(node, key, result) {
    if (result === null) {
        throw cannotRemoveNode(node[key], node, key);
    } else if (Array.isArray(result)) {
        if (result.length === 1) {
            node[key] = result[0];
        } else {
            if (result.length === 0) {
                throw cannotRemoveNode(node[key], node, key);
            } else {
                throw cannotReplaceNode(node[key], node, key);
            }
        }
    } else {
        node[key] = result;
    }
}
function spliceArray(array, index, result) {
    if (result === null) {
        array.splice(index, 1);
        return 0;
    } else if (Array.isArray(result)) {
        array.splice.apply(array, [index, 1].concat(result));
        return result.length;
    } else {
        array.splice(index, 1, result);
        return 1;
    }
}
function traverse(node, visitor) {
    visitNode(normalizeVisitor(visitor), node);
}
function normalizeVisitor(visitor) {
    var normalizedVisitor = {};
    for (var type in visitor) {
        var handler = visitor[type] || visitor.All;
        var normalizedKeys = {};
        if (typeof handler === 'object') {
            var keys = handler.keys;
            if (keys) {
                for (var key in keys) {
                    var keyHandler = keys[key];
                    if (typeof keyHandler === 'object') {
                        normalizedKeys[key] = {
                            enter: typeof keyHandler.enter === 'function' ? keyHandler.enter : null,
                            exit: typeof keyHandler.exit === 'function' ? keyHandler.exit : null
                        };
                    } else if (typeof keyHandler === 'function') {
                        normalizedKeys[key] = {
                            enter: keyHandler,
                            exit: null
                        };
                    }
                }
            }
            normalizedVisitor[type] = {
                enter: typeof handler.enter === 'function' ? handler.enter : null,
                exit: typeof handler.exit === 'function' ? handler.exit : null,
                keys: normalizedKeys
            };
        } else if (typeof handler === 'function') {
            normalizedVisitor[type] = {
                enter: handler,
                exit: null,
                keys: normalizedKeys
            };
        }
    }
    return normalizedVisitor;
}

function unreachable() {
    throw new Error('unreachable');
}
function build(ast) {
    if (!ast) {
        return '';
    }
    var output = [];
    switch (ast.type) {
        case 'Program':
            {
                var chainBlock = ast['chained'] && ast.body[0];
                if (chainBlock) {
                    chainBlock['chained'] = true;
                }
                var body = buildEach(ast.body).join('');
                output.push(body);
            }
            break;
        case 'ElementNode':
            output.push('<', ast.tag);
            if (ast.attributes.length) {
                output.push(' ', buildEach(ast.attributes).join(' '));
            }
            if (ast.modifiers.length) {
                output.push(' ', buildEach(ast.modifiers).join(' '));
            }
            if (ast.comments.length) {
                output.push(' ', buildEach(ast.comments).join(' '));
            }
            output.push('>');
            output.push.apply(output, buildEach(ast.children));
            output.push('</', ast.tag, '>');
            break;
        case 'AttrNode':
            output.push(ast.name, '=');
            var value = build(ast.value);
            if (ast.value.type === 'TextNode') {
                output.push('"', value, '"');
            } else {
                output.push(value);
            }
            break;
        case 'ConcatStatement':
            output.push('"');
            ast.parts.forEach(function (node) {
                if (node.type === 'StringLiteral') {
                    output.push(node.original);
                } else {
                    output.push(build(node));
                }
            });
            output.push('"');
            break;
        case 'TextNode':
            output.push(ast.chars);
            break;
        case 'MustacheStatement':
            {
                output.push(compactJoin(['{{', pathParams(ast), '}}']));
            }
            break;
        case 'MustacheCommentStatement':
            {
                output.push(compactJoin(['{{!--', ast.value, '--}}']));
            }
            break;
        case 'ElementModifierStatement':
            {
                output.push(compactJoin(['{{', pathParams(ast), '}}']));
            }
            break;
        case 'PathExpression':
            output.push(ast.original);
            break;
        case 'SubExpression':
            {
                output.push('(', pathParams(ast), ')');
            }
            break;
        case 'BooleanLiteral':
            output.push(ast.value ? 'true' : 'false');
            break;
        case 'BlockStatement':
            {
                var lines = [];
                if (ast['chained']) {
                    lines.push(['{{else ', pathParams(ast), '}}'].join(''));
                } else {
                    lines.push(openBlock(ast));
                }
                lines.push(build(ast.program));
                if (ast.inverse) {
                    if (!ast.inverse['chained']) {
                        lines.push('{{else}}');
                    }
                    lines.push(build(ast.inverse));
                }
                if (!ast['chained']) {
                    lines.push(closeBlock(ast));
                }
                output.push(lines.join(''));
            }
            break;
        case 'PartialStatement':
            {
                output.push(compactJoin(['{{>', pathParams(ast), '}}']));
            }
            break;
        case 'CommentStatement':
            {
                output.push(compactJoin(['<!--', ast.value, '-->']));
            }
            break;
        case 'StringLiteral':
            {
                output.push('"' + ast.value + '"');
            }
            break;
        case 'NumberLiteral':
            {
                output.push(String(ast.value));
            }
            break;
        case 'UndefinedLiteral':
            {
                output.push('undefined');
            }
            break;
        case 'NullLiteral':
            {
                output.push('null');
            }
            break;
        case 'Hash':
            {
                output.push(ast.pairs.map(function (pair) {
                    return build(pair);
                }).join(' '));
            }
            break;
        case 'HashPair':
            {
                output.push(ast.key + '=' + build(ast.value));
            }
            break;
    }
    return output.join('');
}
function compact(array) {
    var newArray = [];
    array.forEach(function (a) {
        if (typeof a !== 'undefined' && a !== null && a !== '') {
            newArray.push(a);
        }
    });
    return newArray;
}
function buildEach(asts) {
    return asts.map(build);
}
function pathParams(ast) {
    var path = void 0;
    switch (ast.type) {
        case 'MustacheStatement':
        case 'SubExpression':
        case 'ElementModifierStatement':
        case 'BlockStatement':
            if (isLiteral(ast.path)) {
                return String(ast.path.value);
            }
            path = build(ast.path);
            break;
        case 'PartialStatement':
            path = build(ast.name);
            break;
        default:
            return unreachable();
    }
    return compactJoin([path, buildEach(ast.params).join(' '), build(ast.hash)], ' ');
}
function compactJoin(array, delimiter) {
    return compact(array).join(delimiter || '');
}
function blockParams(block) {
    var params = block.program.blockParams;
    if (params.length) {
        return ' as |' + params.join(' ') + '|';
    }
    return null;
}
function openBlock(block) {
    return ['{{#', pathParams(block), blockParams(block), '}}'].join('');
}
function closeBlock(block) {
    return ['{{/', build(block.path), '}}'].join('');
}

function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Walker = function () {
    function Walker(order) {
        _classCallCheck$3(this, Walker);

        this.order = order;
        this.stack = [];
    }

    Walker.prototype.visit = function visit(node, callback) {
        if (!node) {
            return;
        }
        this.stack.push(node);
        if (this.order === 'post') {
            this.children(node, callback);
            callback(node, this);
        } else {
            callback(node, this);
            this.children(node, callback);
        }
        this.stack.pop();
    };

    Walker.prototype.children = function children(node, callback) {
        var visitor = visitors[node.type];
        if (visitor) {
            visitor(this, node, callback);
        }
    };

    return Walker;
}();

var visitors = {
    Program: function Program(walker, node, callback) {
        for (var i = 0; i < node.body.length; i++) {
            walker.visit(node.body[i], callback);
        }
    },
    ElementNode: function ElementNode(walker, node, callback) {
        for (var i = 0; i < node.children.length; i++) {
            walker.visit(node.children[i], callback);
        }
    },
    BlockStatement: function BlockStatement(walker, node, callback) {
        walker.visit(node.program, callback);
        walker.visit(node.inverse || null, callback);
    }
};

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var voidMap = Object.create(null);
var voidTagNames = "area base br col command embed hr img input keygen link meta param source track wbr";
voidTagNames.split(" ").forEach(function (tagName) {
    voidMap[tagName] = true;
});
var TokenizerEventHandlers = function (_HandlebarsNodeVisito) {
    _inherits(TokenizerEventHandlers, _HandlebarsNodeVisito);

    function TokenizerEventHandlers() {
        _classCallCheck(this, TokenizerEventHandlers);

        var _this = _possibleConstructorReturn(this, _HandlebarsNodeVisito.apply(this, arguments));

        _this.tagOpenLine = 0;
        _this.tagOpenColumn = 0;
        return _this;
    }

    TokenizerEventHandlers.prototype.reset = function reset() {
        this.currentNode = null;
    };
    // Comment


    TokenizerEventHandlers.prototype.beginComment = function beginComment() {
        this.currentNode = b.comment("");
        this.currentNode.loc = {
            source: null,
            start: b.pos(this.tagOpenLine, this.tagOpenColumn),
            end: null
        };
    };

    TokenizerEventHandlers.prototype.appendToCommentData = function appendToCommentData(char) {
        this.currentComment.value += char;
    };

    TokenizerEventHandlers.prototype.finishComment = function finishComment() {
        this.currentComment.loc.end = b.pos(this.tokenizer.line, this.tokenizer.column);
        appendChild(this.currentElement(), this.currentComment);
    };
    // Data


    TokenizerEventHandlers.prototype.beginData = function beginData() {
        this.currentNode = b.text();
        this.currentNode.loc = {
            source: null,
            start: b.pos(this.tokenizer.line, this.tokenizer.column),
            end: null
        };
    };

    TokenizerEventHandlers.prototype.appendToData = function appendToData(char) {
        this.currentData.chars += char;
    };

    TokenizerEventHandlers.prototype.finishData = function finishData() {
        this.currentData.loc.end = b.pos(this.tokenizer.line, this.tokenizer.column);
        appendChild(this.currentElement(), this.currentData);
    };
    // Tags - basic


    TokenizerEventHandlers.prototype.tagOpen = function tagOpen() {
        this.tagOpenLine = this.tokenizer.line;
        this.tagOpenColumn = this.tokenizer.column;
    };

    TokenizerEventHandlers.prototype.beginStartTag = function beginStartTag() {
        this.currentNode = {
            type: 'StartTag',
            name: "",
            attributes: [],
            modifiers: [],
            comments: [],
            selfClosing: false,
            loc: SYNTHETIC
        };
    };

    TokenizerEventHandlers.prototype.beginEndTag = function beginEndTag() {
        this.currentNode = {
            type: 'EndTag',
            name: "",
            attributes: [],
            modifiers: [],
            comments: [],
            selfClosing: false,
            loc: SYNTHETIC
        };
    };

    TokenizerEventHandlers.prototype.finishTag = function finishTag() {
        var _tokenizer = this.tokenizer,
            line = _tokenizer.line,
            column = _tokenizer.column;

        var tag = this.currentTag;
        tag.loc = b.loc(this.tagOpenLine, this.tagOpenColumn, line, column);
        if (tag.type === 'StartTag') {
            this.finishStartTag();
            if (voidMap[tag.name] || tag.selfClosing) {
                this.finishEndTag(true);
            }
        } else if (tag.type === 'EndTag') {
            this.finishEndTag(false);
        }
    };

    TokenizerEventHandlers.prototype.finishStartTag = function finishStartTag() {
        var _currentStartTag = this.currentStartTag,
            name = _currentStartTag.name,
            attributes = _currentStartTag.attributes,
            modifiers = _currentStartTag.modifiers,
            comments = _currentStartTag.comments;

        var loc = b.loc(this.tagOpenLine, this.tagOpenColumn);
        var element = b.element(name, attributes, modifiers, [], comments, loc);
        this.elementStack.push(element);
    };

    TokenizerEventHandlers.prototype.finishEndTag = function finishEndTag(isVoid) {
        var tag = this.currentTag;
        var element = this.elementStack.pop();
        var parent = this.currentElement();
        validateEndTag(tag, element, isVoid);
        element.loc.end.line = this.tokenizer.line;
        element.loc.end.column = this.tokenizer.column;
        parseElementBlockParams(element);
        appendChild(parent, element);
    };

    TokenizerEventHandlers.prototype.markTagAsSelfClosing = function markTagAsSelfClosing() {
        this.currentTag.selfClosing = true;
    };
    // Tags - name


    TokenizerEventHandlers.prototype.appendToTagName = function appendToTagName(char) {
        this.currentTag.name += char;
    };
    // Tags - attributes


    TokenizerEventHandlers.prototype.beginAttribute = function beginAttribute() {
        var tag = this.currentTag;
        if (tag.type === 'EndTag') {
            throw new SyntaxError("Invalid end tag: closing tag must not have attributes, " + ("in `" + tag.name + "` (on line " + this.tokenizer.line + ")."), tag.loc);
        }
        this.currentAttribute = {
            name: "",
            parts: [],
            isQuoted: false,
            isDynamic: false,
            start: b.pos(this.tokenizer.line, this.tokenizer.column),
            valueStartLine: 0,
            valueStartColumn: 0
        };
    };

    TokenizerEventHandlers.prototype.appendToAttributeName = function appendToAttributeName(char) {
        this.currentAttr.name += char;
    };

    TokenizerEventHandlers.prototype.beginAttributeValue = function beginAttributeValue(isQuoted) {
        this.currentAttr.isQuoted = isQuoted;
        this.currentAttr.valueStartLine = this.tokenizer.line;
        this.currentAttr.valueStartColumn = this.tokenizer.column;
    };

    TokenizerEventHandlers.prototype.appendToAttributeValue = function appendToAttributeValue(char) {
        var parts = this.currentAttr.parts;
        var lastPart = parts[parts.length - 1];
        if (lastPart && lastPart.type === 'TextNode') {
            lastPart.chars += char;
            // update end location for each added char
            lastPart.loc.end.line = this.tokenizer.line;
            lastPart.loc.end.column = this.tokenizer.column;
        } else {
            // initially assume the text node is a single char
            var loc = b.loc(this.tokenizer.line, this.tokenizer.column, this.tokenizer.line, this.tokenizer.column);
            // correct for `\n` as first char
            if (char === '\n') {
                loc.start.line -= 1;
                loc.start.column = lastPart ? lastPart.loc.end.column : this.currentAttr.valueStartColumn;
            }
            var text = b.text(char, loc);
            parts.push(text);
        }
    };

    TokenizerEventHandlers.prototype.finishAttributeValue = function finishAttributeValue() {
        var _currentAttr = this.currentAttr,
            name = _currentAttr.name,
            parts = _currentAttr.parts,
            isQuoted = _currentAttr.isQuoted,
            isDynamic = _currentAttr.isDynamic,
            valueStartLine = _currentAttr.valueStartLine,
            valueStartColumn = _currentAttr.valueStartColumn;

        var value = assembleAttributeValue(parts, isQuoted, isDynamic, this.tokenizer.line);
        value.loc = b.loc(valueStartLine, valueStartColumn, this.tokenizer.line, this.tokenizer.column);
        var loc = b.loc(this.currentAttr.start.line, this.currentAttr.start.column, this.tokenizer.line, this.tokenizer.column);
        var attribute = b.attr(name, value, loc);
        this.currentStartTag.attributes.push(attribute);
    };

    TokenizerEventHandlers.prototype.reportSyntaxError = function reportSyntaxError(message) {
        throw new SyntaxError("Syntax error at line " + this.tokenizer.line + " col " + this.tokenizer.column + ": " + message, b.loc(this.tokenizer.line, this.tokenizer.column));
    };

    return TokenizerEventHandlers;
}(HandlebarsNodeVisitors);

function assembleAttributeValue(parts, isQuoted, isDynamic, line) {
    if (isDynamic) {
        if (isQuoted) {
            return assembleConcatenatedValue(parts);
        } else {
            if (parts.length === 1 || parts.length === 2 && parts[1].type === 'TextNode' && parts[1].chars === '/') {
                return parts[0];
            } else {
                throw new SyntaxError("An unquoted attribute value must be a string or a mustache, " + "preceeded by whitespace or a '=' character, and " + ("followed by whitespace, a '>' character, or '/>' (on line " + line + ")"), b.loc(line, 0));
            }
        }
    } else {
        return parts.length > 0 ? parts[0] : b.text("");
    }
}
function assembleConcatenatedValue(parts) {
    for (var i = 0; i < parts.length; i++) {
        var part = parts[i];
        if (part.type !== 'MustacheStatement' && part.type !== 'TextNode') {
            throw new SyntaxError("Unsupported node in quoted attribute value: " + part['type'], part.loc);
        }
    }
    return b.concat(parts);
}
function validateEndTag(tag, element, selfClosing) {
    var error = void 0;
    if (voidMap[tag.name] && !selfClosing) {
        // EngTag is also called by StartTag for void and self-closing tags (i.e.
        // <input> or <br />, so we need to check for that here. Otherwise, we would
        // throw an error for those cases.
        error = "Invalid end tag " + formatEndTagInfo(tag) + " (void elements cannot have end tags).";
    } else if (element.tag === undefined) {
        error = "Closing tag " + formatEndTagInfo(tag) + " without an open tag.";
    } else if (element.tag !== tag.name) {
        error = "Closing tag " + formatEndTagInfo(tag) + " did not match last open tag `" + element.tag + "` (on line " + element.loc.start.line + ").";
    }
    if (error) {
        throw new SyntaxError(error, element.loc);
    }
}
function formatEndTagInfo(tag) {
    return "`" + tag.name + "` (on line " + tag.loc.end.line + ")";
}
var syntax = {
    parse: preprocess,
    builders: b,
    print: build,
    traverse: traverse,
    Walker: Walker
};
function preprocess(html, options) {
    var ast = typeof html === 'object' ? html : handlebars.parse(html);
    var program = new TokenizerEventHandlers(html, options).acceptNode(ast);
    if (options && options.plugins && options.plugins.ast) {
        for (var i = 0, l = options.plugins.ast.length; i < l; i++) {
            var transform = options.plugins.ast[i];
            var env = util.assign({}, options, { syntax: syntax }, { plugins: undefined });
            var pluginResult = transform(env);
            traverse(program, pluginResult.visitor);
        }
    }
    return program;
}

// used by ember-compiler
// AST

exports.AST = nodes;
exports.preprocess = preprocess;
exports.builders = b;
exports.TraversalError = TraversalError;
exports.cannotRemoveNode = cannotRemoveNode;
exports.cannotReplaceNode = cannotReplaceNode;
exports.cannotReplaceOrRemoveInKeyHandlerYet = cannotReplaceOrRemoveInKeyHandlerYet;
exports.traverse = traverse;
exports.Walker = Walker;
exports.print = build;
exports.SyntaxError = SyntaxError;
exports.isLiteral = isLiteral$1;
exports.printLiteral = printLiteral;

Object.defineProperty(exports, '__esModule', { value: true });

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2xpbW1lci1zeW50YXguanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvdHlwZXMvbm9kZXMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9zeW50YXgvbGliL2J1aWxkZXJzLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi9lcnJvcnMvc3ludGF4LWVycm9yLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi91dGlscy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvcGFyc2VyLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi9wYXJzZXIvaGFuZGxlYmFycy1ub2RlLXZpc2l0b3JzLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi90eXBlcy92aXNpdG9yLWtleXMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9zeW50YXgvbGliL3RyYXZlcnNhbC9lcnJvcnMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9zeW50YXgvbGliL3RyYXZlcnNhbC90cmF2ZXJzZS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvZ2VuZXJhdGlvbi9wcmludC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvdHJhdmVyc2FsL3dhbGtlci50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvcGFyc2VyL3Rva2VuaXplci1ldmVudC1oYW5kbGVycy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdHlwZSBPcHRpb248VD4gPSBUIHwgbnVsbDtcblxuZXhwb3J0IGludGVyZmFjZSBCYXNlTm9kZSB7XG4gIC8vIEV2ZXJ5IGxlYWYgaW50ZXJmYWNlIHRoYXQgZXh0ZW5kcyBCYXNlTm9kZSBtdXN0IHNwZWNpZnkgYSB0eXBlIHByb3BlcnR5LlxuICAvLyBUaGUgdHlwZSBwcm9wZXJ0eSBzaG91bGQgYmUgYSBzdHJpbmcgbGl0ZXJhbC4gRm9yIGV4YW1wbGUsIElkZW50aWZpZXJcbiAgLy8gaGFzOiBgdHlwZTogXCJJZGVudGlmaWVyXCJgXG4gIHR5cGU6IE5vZGVUeXBlO1xuICBsb2M6IFNvdXJjZUxvY2F0aW9uO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNvdXJjZUxvY2F0aW9uIHtcbiAgc291cmNlPzogT3B0aW9uPHN0cmluZz47XG4gIHN0YXJ0OiBQb3NpdGlvbjtcbiAgZW5kOiBQb3NpdGlvbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQb3NpdGlvbiB7XG4gIC8qKiA+PSAxICovXG4gIGxpbmU6IG51bWJlcjtcbiAgLyoqID49IDAgKi9cbiAgY29sdW1uOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvZ3JhbSBleHRlbmRzIEJhc2VOb2RlIHtcbiAgdHlwZTogJ1Byb2dyYW0nO1xuICBib2R5OiBTdGF0ZW1lbnRbXTtcbiAgYmxvY2tQYXJhbXM6IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgdHlwZSBTdGF0ZW1lbnQgPSBNdXN0YWNoZVN0YXRlbWVudCB8IEJsb2NrU3RhdGVtZW50IHwgUGFydGlhbFN0YXRlbWVudCB8IE11c3RhY2hlQ29tbWVudFN0YXRlbWVudCB8IENvbW1lbnRTdGF0ZW1lbnQgfCBUZXh0Tm9kZSB8IEVsZW1lbnROb2RlO1xuXG5leHBvcnQgaW50ZXJmYWNlIENhbGwgZXh0ZW5kcyBCYXNlTm9kZSB7XG4gIG5hbWU/OiBQYXRoRXhwcmVzc2lvbiB8IFN1YkV4cHJlc3Npb247XG4gIHBhdGg6IFBhdGhFeHByZXNzaW9uO1xuICBwYXJhbXM6IEV4cHJlc3Npb25bXTtcbiAgaGFzaDogSGFzaDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNdXN0YWNoZVN0YXRlbWVudCBleHRlbmRzIEJhc2VOb2RlIHtcbiAgdHlwZTogJ011c3RhY2hlU3RhdGVtZW50JztcbiAgcGF0aDogUGF0aEV4cHJlc3Npb24gfCBMaXRlcmFsO1xuICBwYXJhbXM6IEV4cHJlc3Npb25bXTtcbiAgaGFzaDogSGFzaDtcbiAgZXNjYXBlZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCbG9ja1N0YXRlbWVudCBleHRlbmRzIEJhc2VOb2RlIHtcbiAgdHlwZTogJ0Jsb2NrU3RhdGVtZW50JztcbiAgcGF0aDogUGF0aEV4cHJlc3Npb247XG4gIHBhcmFtczogRXhwcmVzc2lvbltdO1xuICBoYXNoOiBIYXNoO1xuICBwcm9ncmFtOiBQcm9ncmFtO1xuICBpbnZlcnNlPzogT3B0aW9uPFByb2dyYW0+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVsZW1lbnRNb2RpZmllclN0YXRlbWVudCBleHRlbmRzIEJhc2VOb2RlIHtcbiAgdHlwZTogJ0VsZW1lbnRNb2RpZmllclN0YXRlbWVudCc7XG4gIHBhdGg6IFBhdGhFeHByZXNzaW9uO1xuICBwYXJhbXM6IEV4cHJlc3Npb25bXTtcbiAgaGFzaDogSGFzaDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXJ0aWFsU3RhdGVtZW50IGV4dGVuZHMgQmFzZU5vZGUge1xuICB0eXBlOiAnUGFydGlhbFN0YXRlbWVudCc7XG4gIG5hbWU6IFBhdGhFeHByZXNzaW9uIHwgU3ViRXhwcmVzc2lvbjtcbiAgcGFyYW1zOiBFeHByZXNzaW9uW107XG4gIGhhc2g6IEhhc2g7XG4gIGluZGVudDogc3RyaW5nO1xuICBzdHJpcDogU3RyaXBGbGFncztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ2FsbChub2RlOiBhbnkpOiBub2RlIGlzIENhbGwge1xuICByZXR1cm4gbm9kZS50eXBlID09PSAnU3ViRXhwcmVzc2lvbicgfHxcbiAgICAobm9kZS50eXBlID09PSAnTXVzdGFjaGVTdGF0ZW1lbnQnICYmIG5vZGUucGF0aC50eXBlID09PSAnUGF0aEV4cHJlc3Npb24nKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21tZW50U3RhdGVtZW50IGV4dGVuZHMgQmFzZU5vZGUge1xuICB0eXBlOiAnQ29tbWVudFN0YXRlbWVudCc7XG4gIHZhbHVlOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTXVzdGFjaGVDb21tZW50U3RhdGVtZW50IGV4dGVuZHMgQmFzZU5vZGUge1xuICB0eXBlOiAnTXVzdGFjaGVDb21tZW50U3RhdGVtZW50JztcbiAgdmFsdWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFbGVtZW50Tm9kZSBleHRlbmRzIEJhc2VOb2RlIHtcbiAgdHlwZTogJ0VsZW1lbnROb2RlJztcbiAgdGFnOiBzdHJpbmc7XG4gIGF0dHJpYnV0ZXM6IEF0dHJOb2RlW107XG4gIGJsb2NrUGFyYW1zOiBzdHJpbmdbXTtcbiAgbW9kaWZpZXJzOiBFbGVtZW50TW9kaWZpZXJTdGF0ZW1lbnRbXTtcbiAgY29tbWVudHM6IE11c3RhY2hlQ29tbWVudFN0YXRlbWVudFtdO1xuICBjaGlsZHJlbjogU3RhdGVtZW50W107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXR0ck5vZGUgZXh0ZW5kcyBCYXNlTm9kZSB7XG4gIHR5cGU6ICdBdHRyTm9kZSc7XG4gIG5hbWU6IHN0cmluZztcbiAgdmFsdWU6IFRleHROb2RlIHwgTXVzdGFjaGVTdGF0ZW1lbnQgfCBDb25jYXRTdGF0ZW1lbnQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dE5vZGUgZXh0ZW5kcyBCYXNlTm9kZSB7XG4gIHR5cGU6ICdUZXh0Tm9kZSc7XG4gIGNoYXJzOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29uY2F0U3RhdGVtZW50IGV4dGVuZHMgQmFzZU5vZGUge1xuICB0eXBlOiAnQ29uY2F0U3RhdGVtZW50JztcbiAgcGFydHM6IChUZXh0Tm9kZSB8IE11c3RhY2hlU3RhdGVtZW50KVtdO1xufVxuXG5leHBvcnQgdHlwZSBFeHByZXNzaW9uID0gU3ViRXhwcmVzc2lvbiB8IFBhdGhFeHByZXNzaW9uIHwgTGl0ZXJhbDtcblxuZXhwb3J0IGludGVyZmFjZSBTdWJFeHByZXNzaW9uIGV4dGVuZHMgQ2FsbCB7XG4gIHR5cGU6ICdTdWJFeHByZXNzaW9uJztcbiAgcGF0aDogUGF0aEV4cHJlc3Npb247XG4gIHBhcmFtczogRXhwcmVzc2lvbltdO1xuICBoYXNoOiBIYXNoO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhdGhFeHByZXNzaW9uIGV4dGVuZHMgQmFzZU5vZGUge1xuICB0eXBlOiAnUGF0aEV4cHJlc3Npb24nO1xuICBkYXRhOiBib29sZWFuO1xuICBvcmlnaW5hbDogc3RyaW5nO1xuICB0aGlzOiBib29sZWFuO1xuICBwYXJ0czogc3RyaW5nW107XG59XG5cbmV4cG9ydCB0eXBlIExpdGVyYWwgPSBTdHJpbmdMaXRlcmFsIHwgQm9vbGVhbkxpdGVyYWwgfCBOdW1iZXJMaXRlcmFsIHwgVW5kZWZpbmVkTGl0ZXJhbCB8IE51bGxMaXRlcmFsO1xuXG5leHBvcnQgaW50ZXJmYWNlIFN0cmluZ0xpdGVyYWwgZXh0ZW5kcyBCYXNlTm9kZSB7XG4gIHR5cGU6ICdTdHJpbmdMaXRlcmFsJztcbiAgdmFsdWU6IHN0cmluZztcbiAgb3JpZ2luYWw6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCb29sZWFuTGl0ZXJhbCBleHRlbmRzIEJhc2VOb2RlIHtcbiAgdHlwZTogJ0Jvb2xlYW5MaXRlcmFsJztcbiAgdmFsdWU6IGJvb2xlYW47XG4gIG9yaWdpbmFsOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE51bWJlckxpdGVyYWwgZXh0ZW5kcyBCYXNlTm9kZSB7XG4gIHR5cGU6ICdOdW1iZXJMaXRlcmFsJztcbiAgdmFsdWU6IG51bWJlcjtcbiAgb3JpZ2luYWw6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVbmRlZmluZWRMaXRlcmFsIGV4dGVuZHMgQmFzZU5vZGUge1xuICB0eXBlOiAnVW5kZWZpbmVkTGl0ZXJhbCc7XG4gIHZhbHVlOiB1bmRlZmluZWQ7XG4gIG9yaWdpbmFsOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTnVsbExpdGVyYWwgZXh0ZW5kcyBCYXNlTm9kZSB7XG4gIHR5cGU6ICdOdWxsTGl0ZXJhbCc7XG4gIHZhbHVlOiBudWxsO1xuICBvcmlnaW5hbDogbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTGl0ZXJhbChpbnB1dDogTm9kZSB8IHN0cmluZyk6IGlucHV0IGlzIExpdGVyYWwge1xuICByZXR1cm4gISEodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dC50eXBlLm1hdGNoKC9MaXRlcmFsJC8pKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIYXNoIGV4dGVuZHMgQmFzZU5vZGUge1xuICB0eXBlOiAnSGFzaCc7XG4gIHBhaXJzOiBIYXNoUGFpcltdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhhc2hQYWlyIGV4dGVuZHMgQmFzZU5vZGUge1xuICB0eXBlOiAnSGFzaFBhaXInO1xuICBrZXk6IHN0cmluZztcbiAgdmFsdWU6IEV4cHJlc3Npb247XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RyaXBGbGFncyB7XG4gIG9wZW46IGJvb2xlYW47XG4gIGNsb3NlOiBib29sZWFuO1xufVxuXG5leHBvcnQgdHlwZSBOb2RlVHlwZSA9IGtleW9mIE5vZGVzO1xuXG5leHBvcnQgdHlwZSBOb2RlID0gTm9kZXNbTm9kZVR5cGVdO1xuXG5leHBvcnQgaW50ZXJmYWNlIE5vZGVzIHtcbiAgUHJvZ3JhbTogUHJvZ3JhbTtcbiAgRWxlbWVudE5vZGU6IEVsZW1lbnROb2RlO1xuICBBdHRyTm9kZTogQXR0ck5vZGU7XG4gIFRleHROb2RlOiBUZXh0Tm9kZTtcbiAgTXVzdGFjaGVTdGF0ZW1lbnQ6IE11c3RhY2hlU3RhdGVtZW50O1xuICBCbG9ja1N0YXRlbWVudDogQmxvY2tTdGF0ZW1lbnQ7XG4gIFBhcnRpYWxTdGF0ZW1lbnQ6IFBhcnRpYWxTdGF0ZW1lbnQ7XG4gIENvbmNhdFN0YXRlbWVudDogQ29uY2F0U3RhdGVtZW50O1xuICBNdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQ6IE11c3RhY2hlQ29tbWVudFN0YXRlbWVudDtcbiAgRWxlbWVudE1vZGlmaWVyU3RhdGVtZW50OiBFbGVtZW50TW9kaWZpZXJTdGF0ZW1lbnQ7XG4gIENvbW1lbnRTdGF0ZW1lbnQ6IENvbW1lbnRTdGF0ZW1lbnQ7XG4gIFBhdGhFeHByZXNzaW9uOiBQYXRoRXhwcmVzc2lvbjtcbiAgU3ViRXhwcmVzc2lvbjogU3ViRXhwcmVzc2lvbjtcbiAgSGFzaDogSGFzaDtcbiAgSGFzaFBhaXI6IEhhc2hQYWlyO1xuICBTdHJpbmdMaXRlcmFsOiBTdHJpbmdMaXRlcmFsO1xuICBCb29sZWFuTGl0ZXJhbDogQm9vbGVhbkxpdGVyYWw7XG4gIE51bWJlckxpdGVyYWw6IE51bWJlckxpdGVyYWw7XG4gIFVuZGVmaW5lZExpdGVyYWw6IFVuZGVmaW5lZExpdGVyYWw7XG4gIE51bGxMaXRlcmFsOiBOdWxsTGl0ZXJhbDtcbn1cbiIsImltcG9ydCAqIGFzIEFTVCBmcm9tICcuL3R5cGVzL25vZGVzJztcbmltcG9ydCB7IE9wdGlvbiB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuXG4vLyBTdGF0ZW1lbnRzXG5cbmV4cG9ydCB0eXBlIEJ1aWxkZXJQYXRoID0gc3RyaW5nIHwgQVNULlBhdGhFeHByZXNzaW9uO1xuXG5mdW5jdGlvbiBidWlsZE11c3RhY2hlKHBhdGg6IEJ1aWxkZXJQYXRoIHwgQVNULkxpdGVyYWwsIHBhcmFtcz86IEFTVC5FeHByZXNzaW9uW10sIGhhc2g/OiBBU1QuSGFzaCwgcmF3PzogYm9vbGVhbiwgbG9jPzogQVNULlNvdXJjZUxvY2F0aW9uKTogQVNULk11c3RhY2hlU3RhdGVtZW50IHtcbiAgaWYgKCFBU1QuaXNMaXRlcmFsKHBhdGgpKSB7XG4gICAgcGF0aCA9IGJ1aWxkUGF0aChwYXRoKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJNdXN0YWNoZVN0YXRlbWVudFwiLFxuICAgIHBhdGgsXG4gICAgcGFyYW1zOiBwYXJhbXMgfHwgW10sXG4gICAgaGFzaDogaGFzaCB8fCBidWlsZEhhc2goW10pLFxuICAgIGVzY2FwZWQ6ICFyYXcsXG4gICAgbG9jOiBidWlsZExvYyhsb2MgfHwgbnVsbClcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRCbG9jayhwYXRoOiBCdWlsZGVyUGF0aCwgcGFyYW1zOiBPcHRpb248QVNULkV4cHJlc3Npb25bXT4sIGhhc2g6IE9wdGlvbjxBU1QuSGFzaD4sIHByb2dyYW06IEFTVC5Qcm9ncmFtLCBpbnZlcnNlPzogT3B0aW9uPEFTVC5Qcm9ncmFtPiwgbG9jPzogQVNULlNvdXJjZUxvY2F0aW9uKTogQVNULkJsb2NrU3RhdGVtZW50IHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIkJsb2NrU3RhdGVtZW50XCIsXG4gICAgcGF0aDogYnVpbGRQYXRoKHBhdGgpLFxuICAgIHBhcmFtczogcGFyYW1zIHx8IFtdLFxuICAgIGhhc2g6IGhhc2ggfHwgYnVpbGRIYXNoKFtdKSxcbiAgICBwcm9ncmFtOiBwcm9ncmFtIHx8IG51bGwsXG4gICAgaW52ZXJzZTogaW52ZXJzZSB8fCBudWxsLFxuICAgIGxvYzogYnVpbGRMb2MobG9jIHx8IG51bGwpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRWxlbWVudE1vZGlmaWVyKHBhdGg6IEJ1aWxkZXJQYXRoLCBwYXJhbXM/OiBBU1QuRXhwcmVzc2lvbltdLCBoYXNoPzogQVNULkhhc2gsIGxvYz86IE9wdGlvbjxBU1QuU291cmNlTG9jYXRpb24+KTogQVNULkVsZW1lbnRNb2RpZmllclN0YXRlbWVudCB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJFbGVtZW50TW9kaWZpZXJTdGF0ZW1lbnRcIixcbiAgICBwYXRoOiBidWlsZFBhdGgocGF0aCksXG4gICAgcGFyYW1zOiBwYXJhbXMgfHwgW10sXG4gICAgaGFzaDogaGFzaCB8fCBidWlsZEhhc2goW10pLFxuICAgIGxvYzogYnVpbGRMb2MobG9jIHx8IG51bGwpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUGFydGlhbChuYW1lOiBBU1QuUGF0aEV4cHJlc3Npb24sIHBhcmFtcz86IEFTVC5FeHByZXNzaW9uW10sIGhhc2g/OiBBU1QuSGFzaCwgaW5kZW50Pzogc3RyaW5nLCBsb2M/OiBBU1QuU291cmNlTG9jYXRpb24pOiBBU1QuUGFydGlhbFN0YXRlbWVudCB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJQYXJ0aWFsU3RhdGVtZW50XCIsXG4gICAgbmFtZTogbmFtZSxcbiAgICBwYXJhbXM6IHBhcmFtcyB8fCBbXSxcbiAgICBoYXNoOiBoYXNoIHx8IGJ1aWxkSGFzaChbXSksXG4gICAgaW5kZW50OiBpbmRlbnQgfHwgJycsXG4gICAgc3RyaXA6IHsgb3BlbjogZmFsc2UsIGNsb3NlOiBmYWxzZSB9LFxuICAgIGxvYzogYnVpbGRMb2MobG9jIHx8IG51bGwpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQ29tbWVudCh2YWx1ZTogc3RyaW5nLCBsb2M/OiBBU1QuU291cmNlTG9jYXRpb24pOiBBU1QuQ29tbWVudFN0YXRlbWVudCB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJDb21tZW50U3RhdGVtZW50XCIsXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGxvYzogYnVpbGRMb2MobG9jIHx8IG51bGwpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTXVzdGFjaGVDb21tZW50KHZhbHVlOiBzdHJpbmcsIGxvYz86IEFTVC5Tb3VyY2VMb2NhdGlvbik6IEFTVC5NdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiTXVzdGFjaGVDb21tZW50U3RhdGVtZW50XCIsXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGxvYzogYnVpbGRMb2MobG9jIHx8IG51bGwpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQ29uY2F0KHBhcnRzOiAoQVNULlRleHROb2RlIHwgQVNULk11c3RhY2hlU3RhdGVtZW50KVtdLCBsb2M/OiBBU1QuU291cmNlTG9jYXRpb24pOiBBU1QuQ29uY2F0U3RhdGVtZW50IHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIkNvbmNhdFN0YXRlbWVudFwiLFxuICAgIHBhcnRzOiBwYXJ0cyB8fCBbXSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKVxuICB9O1xufVxuXG4vLyBOb2Rlc1xuXG5mdW5jdGlvbiBidWlsZEVsZW1lbnQodGFnOiBzdHJpbmcsIGF0dHJpYnV0ZXM/OiBBU1QuQXR0ck5vZGVbXSwgbW9kaWZpZXJzPzogQVNULkVsZW1lbnRNb2RpZmllclN0YXRlbWVudFtdLCBjaGlsZHJlbj86IEFTVC5TdGF0ZW1lbnRbXSwgbG9jPzogQVNULlNvdXJjZUxvY2F0aW9uKTogQVNULkVsZW1lbnROb2RlO1xuZnVuY3Rpb24gYnVpbGRFbGVtZW50KHRhZzogc3RyaW5nLCBhdHRyaWJ1dGVzPzogQVNULkF0dHJOb2RlW10sIG1vZGlmaWVycz86IEFTVC5FbGVtZW50TW9kaWZpZXJTdGF0ZW1lbnRbXSwgY2hpbGRyZW4/OiBBU1QuU3RhdGVtZW50W10sIGNvbW1lbnRzPzogQVNULk11c3RhY2hlQ29tbWVudFN0YXRlbWVudFtdLCBsb2M/OiBBU1QuU291cmNlTG9jYXRpb24pOiBBU1QuRWxlbWVudE5vZGU7XG5cbmZ1bmN0aW9uIGJ1aWxkRWxlbWVudCh0YWc6IHN0cmluZywgYXR0cmlidXRlcz86IEFTVC5BdHRyTm9kZVtdLCBtb2RpZmllcnM/OiBBU1QuRWxlbWVudE1vZGlmaWVyU3RhdGVtZW50W10sIGNoaWxkcmVuPzogQVNULlN0YXRlbWVudFtdLCBjb21tZW50cz86IEFTVC5NdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnRbXSB8IEFTVC5Tb3VyY2VMb2NhdGlvbiwgbG9jPzogQVNULlNvdXJjZUxvY2F0aW9uKTogQVNULkVsZW1lbnROb2RlIHtcbiAgLy8gdGhpcyBpcyB1c2VkIGZvciBiYWNrd2FyZHMgY29tcGF0IHByaW9yIHRvIGBjb21tZW50c2AgYmVpbmcgYWRkZWQgdG8gdGhlIEFTVFxuICBpZiAoIUFycmF5LmlzQXJyYXkoY29tbWVudHMpKSB7XG4gICAgbG9jID0gY29tbWVudHM7XG4gICAgY29tbWVudHMgPSBbXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJFbGVtZW50Tm9kZVwiLFxuICAgIHRhZzogdGFnIHx8IFwiXCIsXG4gICAgYXR0cmlidXRlczogYXR0cmlidXRlcyB8fCBbXSxcbiAgICBibG9ja1BhcmFtczogW10sXG4gICAgbW9kaWZpZXJzOiBtb2RpZmllcnMgfHwgW10sXG4gICAgY29tbWVudHM6IGNvbW1lbnRzIHx8IFtdLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbiB8fCBbXSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKVxuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZEF0dHIobmFtZTogc3RyaW5nLCB2YWx1ZTogQVNULkF0dHJOb2RlWyd2YWx1ZSddLCBsb2M/OiBBU1QuU291cmNlTG9jYXRpb24pOiBBU1QuQXR0ck5vZGUge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiQXR0ck5vZGVcIixcbiAgICBuYW1lOiBuYW1lLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKVxuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZFRleHQoY2hhcnM/OiBzdHJpbmcsIGxvYz86IEFTVC5Tb3VyY2VMb2NhdGlvbik6IEFTVC5UZXh0Tm9kZSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJUZXh0Tm9kZVwiLFxuICAgIGNoYXJzOiBjaGFycyB8fCBcIlwiLFxuICAgIGxvYzogYnVpbGRMb2MobG9jIHx8IG51bGwpXG4gIH07XG59XG5cbi8vIEV4cHJlc3Npb25zXG5cbmZ1bmN0aW9uIGJ1aWxkU2V4cHIocGF0aDogQVNULlBhdGhFeHByZXNzaW9uLCBwYXJhbXM/OiBBU1QuRXhwcmVzc2lvbltdLCBoYXNoPzogQVNULkhhc2gsIGxvYz86IEFTVC5Tb3VyY2VMb2NhdGlvbik6IEFTVC5TdWJFeHByZXNzaW9uIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIlN1YkV4cHJlc3Npb25cIixcbiAgICBwYXRoOiBidWlsZFBhdGgocGF0aCksXG4gICAgcGFyYW1zOiBwYXJhbXMgfHwgW10sXG4gICAgaGFzaDogaGFzaCB8fCBidWlsZEhhc2goW10pLFxuICAgIGxvYzogYnVpbGRMb2MobG9jIHx8IG51bGwpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUGF0aChvcmlnaW5hbDogQnVpbGRlclBhdGgsIGxvYz86IEFTVC5Tb3VyY2VMb2NhdGlvbik6IEFTVC5QYXRoRXhwcmVzc2lvbiB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdzdHJpbmcnKSByZXR1cm4gb3JpZ2luYWw7XG5cbiAgbGV0IHBhcnRzID0gb3JpZ2luYWwuc3BsaXQoJy4nKTtcbiAgbGV0IHRoaXNIZWFkID0gZmFsc2U7XG5cbiAgaWYgKHBhcnRzWzBdID09PSAndGhpcycpIHtcbiAgICB0aGlzSGVhZCA9IHRydWU7XG4gICAgcGFydHMgPSBwYXJ0cy5zbGljZSgxKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJQYXRoRXhwcmVzc2lvblwiLFxuICAgIG9yaWdpbmFsLFxuICAgIHRoaXM6IHRoaXNIZWFkLFxuICAgIHBhcnRzLFxuICAgIGRhdGE6IGZhbHNlLFxuICAgIGxvYzogYnVpbGRMb2MobG9jIHx8IG51bGwpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTGl0ZXJhbDxUIGV4dGVuZHMgQVNULkxpdGVyYWw+KHR5cGU6IFRbJ3R5cGUnXSwgdmFsdWU6IFRbJ3ZhbHVlJ10sIGxvYz86IEFTVC5Tb3VyY2VMb2NhdGlvbik6IEFTVC5MaXRlcmFsIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIHZhbHVlLFxuICAgIG9yaWdpbmFsOiB2YWx1ZSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKVxuICB9IGFzIEFTVC5MaXRlcmFsO1xufVxuXG4vLyBNaXNjZWxsYW5lb3VzXG5cbmZ1bmN0aW9uIGJ1aWxkSGFzaChwYWlycz86IEFTVC5IYXNoUGFpcltdLCBsb2M/OiBBU1QuU291cmNlTG9jYXRpb24pOiBBU1QuSGFzaCB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJIYXNoXCIsXG4gICAgcGFpcnM6IHBhaXJzIHx8IFtdLFxuICAgIGxvYzogYnVpbGRMb2MobG9jIHx8IG51bGwpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUGFpcihrZXk6IHN0cmluZywgdmFsdWU6IEFTVC5FeHByZXNzaW9uLCBsb2M/OiBBU1QuU291cmNlTG9jYXRpb24pOiBBU1QuSGFzaFBhaXIge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiSGFzaFBhaXJcIixcbiAgICBrZXk6IGtleSxcbiAgICB2YWx1ZSxcbiAgICBsb2M6IGJ1aWxkTG9jKGxvYyB8fCBudWxsKVxuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZFByb2dyYW0oYm9keT86IEFTVC5TdGF0ZW1lbnRbXSwgYmxvY2tQYXJhbXM/OiBzdHJpbmdbXSwgbG9jPzogQVNULlNvdXJjZUxvY2F0aW9uKTogQVNULlByb2dyYW0ge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiUHJvZ3JhbVwiLFxuICAgIGJvZHk6IGJvZHkgfHwgW10sXG4gICAgYmxvY2tQYXJhbXM6IGJsb2NrUGFyYW1zIHx8IFtdLFxuICAgIGxvYzogYnVpbGRMb2MobG9jIHx8IG51bGwpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkU291cmNlKHNvdXJjZT86IHN0cmluZykge1xuICByZXR1cm4gc291cmNlIHx8IG51bGw7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUG9zaXRpb24obGluZTogbnVtYmVyLCBjb2x1bW46IG51bWJlcikge1xuICByZXR1cm4ge1xuICAgIGxpbmUsXG4gICAgY29sdW1uXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBTWU5USEVUSUM6IEFTVC5Tb3VyY2VMb2NhdGlvbiA9IHsgc291cmNlOiAnKHN5bnRoZXRpYyknLCBzdGFydDogeyBsaW5lOiAxLCBjb2x1bW46IDAgfSwgZW5kOiB7IGxpbmU6IDEsIGNvbHVtbjogMCB9IH07XG5cbmZ1bmN0aW9uIGJ1aWxkTG9jKGxvYzpPcHRpb248QVNULlNvdXJjZUxvY2F0aW9uPik6IEFTVC5Tb3VyY2VMb2NhdGlvbjtcbmZ1bmN0aW9uIGJ1aWxkTG9jKHN0YXJ0TGluZTogbnVtYmVyLCBzdGFydENvbHVtbjogbnVtYmVyLCBlbmRMaW5lPzogbnVtYmVyLCBlbmRDb2x1bW4/OiBudW1iZXIsIHNvdXJjZT86IHN0cmluZyk6IEFTVC5Tb3VyY2VMb2NhdGlvbjtcblxuZnVuY3Rpb24gYnVpbGRMb2MoLi4uYXJnczogYW55W10pOiBBU1QuU291cmNlTG9jYXRpb24ge1xuICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICBsZXQgbG9jID0gYXJnc1swXTtcblxuICAgIGlmIChsb2MgJiYgdHlwZW9mIGxvYyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogYnVpbGRTb3VyY2UobG9jLnNvdXJjZSksXG4gICAgICAgIHN0YXJ0OiBidWlsZFBvc2l0aW9uKGxvYy5zdGFydC5saW5lLCBsb2Muc3RhcnQuY29sdW1uKSxcbiAgICAgICAgZW5kOiBidWlsZFBvc2l0aW9uKGxvYy5lbmQubGluZSwgbG9jLmVuZC5jb2x1bW4pXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gU1lOVEhFVElDO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgWyBzdGFydExpbmUsIHN0YXJ0Q29sdW1uLCBlbmRMaW5lLCBlbmRDb2x1bW4sIHNvdXJjZSBdID0gYXJncztcbiAgICByZXR1cm4ge1xuICAgICAgc291cmNlOiBidWlsZFNvdXJjZShzb3VyY2UpLFxuICAgICAgc3RhcnQ6IGJ1aWxkUG9zaXRpb24oc3RhcnRMaW5lLCBzdGFydENvbHVtbiksXG4gICAgICBlbmQ6IGJ1aWxkUG9zaXRpb24oZW5kTGluZSwgZW5kQ29sdW1uKVxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBtdXN0YWNoZTogYnVpbGRNdXN0YWNoZSxcbiAgYmxvY2s6IGJ1aWxkQmxvY2ssXG4gIHBhcnRpYWw6IGJ1aWxkUGFydGlhbCxcbiAgY29tbWVudDogYnVpbGRDb21tZW50LFxuICBtdXN0YWNoZUNvbW1lbnQ6IGJ1aWxkTXVzdGFjaGVDb21tZW50LFxuICBlbGVtZW50OiBidWlsZEVsZW1lbnQsXG4gIGVsZW1lbnRNb2RpZmllcjogYnVpbGRFbGVtZW50TW9kaWZpZXIsXG4gIGF0dHI6IGJ1aWxkQXR0cixcbiAgdGV4dDogYnVpbGRUZXh0LFxuICBzZXhwcjogYnVpbGRTZXhwcixcbiAgcGF0aDogYnVpbGRQYXRoLFxuICBjb25jYXQ6IGJ1aWxkQ29uY2F0LFxuICBoYXNoOiBidWlsZEhhc2gsXG4gIHBhaXI6IGJ1aWxkUGFpcixcbiAgbGl0ZXJhbDogYnVpbGRMaXRlcmFsLFxuICBwcm9ncmFtOiBidWlsZFByb2dyYW0sXG4gIGxvYzogYnVpbGRMb2MsXG4gIHBvczogYnVpbGRQb3NpdGlvbixcblxuICBzdHJpbmc6IGxpdGVyYWwoJ1N0cmluZ0xpdGVyYWwnKSxcbiAgYm9vbGVhbjogbGl0ZXJhbCgnQm9vbGVhbkxpdGVyYWwnKSxcbiAgbnVtYmVyOiBsaXRlcmFsKCdOdW1iZXJMaXRlcmFsJyksXG4gIHVuZGVmaW5lZCgpIHsgcmV0dXJuIGJ1aWxkTGl0ZXJhbCgnVW5kZWZpbmVkTGl0ZXJhbCcsIHVuZGVmaW5lZCk7IH0sXG4gIG51bGwoKSB7IHJldHVybiBidWlsZExpdGVyYWwoJ051bGxMaXRlcmFsJywgbnVsbCk7IH1cbn07XG5cbmZ1bmN0aW9uIGxpdGVyYWw8VCBleHRlbmRzIEFTVC5MaXRlcmFsPih0eXBlOiBUWyd0eXBlJ10pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlOiBUWyd2YWx1ZSddKSB7XG4gICAgcmV0dXJuIGJ1aWxkTGl0ZXJhbCh0eXBlLCB2YWx1ZSk7XG4gIH07XG59XG4iLCJpbXBvcnQgKiBhcyBBU1QgZnJvbSAnLi4vdHlwZXMvbm9kZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFN5bnRheEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBsb2NhdGlvbjogQVNULlNvdXJjZUxvY2F0aW9uO1xuICBjb25zdHJ1Y3RvcjogU3ludGF4RXJyb3JDb25zdHJ1Y3Rvcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTeW50YXhFcnJvckNvbnN0cnVjdG9yIHtcbiAgbmV3IChtZXNzYWdlOiBzdHJpbmcsIGxvY2F0aW9uOiBBU1QuU291cmNlTG9jYXRpb24pOiBTeW50YXhFcnJvcjtcbiAgcmVhZG9ubHkgcHJvdG90eXBlOiBTeW50YXhFcnJvcjtcbn1cblxuLyoqXG4gKiBTdWJjbGFzcyBvZiBgRXJyb3JgIHdpdGggYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuICogYWJvdXQgbG9jYXRpb24gb2YgaW5jb3JyZWN0IG1hcmt1cC5cbiAqL1xuY29uc3QgU3ludGF4RXJyb3I6IFN5bnRheEVycm9yQ29uc3RydWN0b3IgPSAoZnVuY3Rpb24gKCkge1xuICBTeW50YXhFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gIFN5bnRheEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN5bnRheEVycm9yO1xuXG4gIGZ1bmN0aW9uIFN5bnRheEVycm9yKHRoaXM6IFN5bnRheEVycm9yLCBtZXNzYWdlOiBzdHJpbmcsIGxvY2F0aW9uOiBBU1QuU291cmNlTG9jYXRpb24pIHtcbiAgICBsZXQgZXJyb3IgPSBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gZXJyb3Iuc3RhY2s7XG4gICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICB9XG5cbiAgcmV0dXJuIFN5bnRheEVycm9yIGFzIGFueTtcbn0oKSk7XG5cbmV4cG9ydCBkZWZhdWx0IFN5bnRheEVycm9yO1xuIiwiaW1wb3J0ICogYXMgQVNUIGZyb20gJy4vdHlwZXMvbm9kZXMnO1xuaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSBcIkBnbGltbWVyL2ludGVyZmFjZXNcIjtcbmltcG9ydCBTeW50YXhFcnJvciBmcm9tICcuL2Vycm9ycy9zeW50YXgtZXJyb3InO1xuXG4vLyBSZWdleCB0byB2YWxpZGF0ZSB0aGUgaWRlbnRpZmllciBmb3IgYmxvY2sgcGFyYW1ldGVycy5cbi8vIEJhc2VkIG9uIHRoZSBJRCB2YWxpZGF0aW9uIHJlZ2V4IGluIEhhbmRsZWJhcnMuXG5cbmxldCBJRF9JTlZFUlNFX1BBVFRFUk4gPSAvWyFcIiMlLSxcXC5cXC87LT5AXFxbLVxcXmBcXHstfl0vO1xuXG4vLyBDaGVja3MgdGhlIGVsZW1lbnQncyBhdHRyaWJ1dGVzIHRvIHNlZSBpZiBpdCB1c2VzIGJsb2NrIHBhcmFtcy5cbi8vIElmIGl0IGRvZXMsIHJlZ2lzdGVycyB0aGUgYmxvY2sgcGFyYW1zIHdpdGggdGhlIHByb2dyYW0gYW5kXG4vLyByZW1vdmVzIHRoZSBjb3JyZXNwb25kaW5nIGF0dHJpYnV0ZXMgZnJvbSB0aGUgZWxlbWVudC5cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRWxlbWVudEJsb2NrUGFyYW1zKGVsZW1lbnQ6IEFTVC5FbGVtZW50Tm9kZSkge1xuICBsZXQgcGFyYW1zID0gcGFyc2VCbG9ja1BhcmFtcyhlbGVtZW50KTtcbiAgaWYgKHBhcmFtcykgZWxlbWVudC5ibG9ja1BhcmFtcyA9IHBhcmFtcztcbn1cblxuZnVuY3Rpb24gcGFyc2VCbG9ja1BhcmFtcyhlbGVtZW50OiBBU1QuRWxlbWVudE5vZGUpOiBPcHRpb248c3RyaW5nW10+IHtcbiAgbGV0IGwgPSBlbGVtZW50LmF0dHJpYnV0ZXMubGVuZ3RoO1xuICBsZXQgYXR0ck5hbWVzID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICBhdHRyTmFtZXMucHVzaChlbGVtZW50LmF0dHJpYnV0ZXNbaV0ubmFtZSk7XG4gIH1cblxuICBsZXQgYXNJbmRleCA9IGF0dHJOYW1lcy5pbmRleE9mKCdhcycpO1xuXG4gIGlmIChhc0luZGV4ICE9PSAtMSAmJiBsID4gYXNJbmRleCAmJiBhdHRyTmFtZXNbYXNJbmRleCArIDFdLmNoYXJBdCgwKSA9PT0gJ3wnKSB7XG4gICAgLy8gU29tZSBiYXNpYyB2YWxpZGF0aW9uLCBzaW5jZSB3ZSdyZSBkb2luZyB0aGUgcGFyc2luZyBvdXJzZWx2ZXNcbiAgICBsZXQgcGFyYW1zU3RyaW5nID0gYXR0ck5hbWVzLnNsaWNlKGFzSW5kZXgpLmpvaW4oJyAnKTtcbiAgICBpZiAocGFyYW1zU3RyaW5nLmNoYXJBdChwYXJhbXNTdHJpbmcubGVuZ3RoIC0gMSkgIT09ICd8JyB8fCBwYXJhbXNTdHJpbmcubWF0Y2goL1xcfC9nKSEubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0ludmFsaWQgYmxvY2sgcGFyYW1ldGVycyBzeW50YXg6IFxcJycgKyBwYXJhbXNTdHJpbmcgKyAnXFwnJywgZWxlbWVudC5sb2MpO1xuICAgIH1cblxuICAgIGxldCBwYXJhbXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gYXNJbmRleCArIDE7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxldCBwYXJhbSA9IGF0dHJOYW1lc1tpXS5yZXBsYWNlKC9cXHwvZywgJycpO1xuICAgICAgaWYgKHBhcmFtICE9PSAnJykge1xuICAgICAgICBpZiAoSURfSU5WRVJTRV9QQVRURVJOLnRlc3QocGFyYW0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdJbnZhbGlkIGlkZW50aWZpZXIgZm9yIGJsb2NrIHBhcmFtZXRlcnM6IFxcJycgKyBwYXJhbSArICdcXCcgaW4gXFwnJyArIHBhcmFtc1N0cmluZyArICdcXCcnLCBlbGVtZW50LmxvYyk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXJhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0Nhbm5vdCB1c2UgemVybyBibG9jayBwYXJhbWV0ZXJzOiBcXCcnICsgcGFyYW1zU3RyaW5nICsgJ1xcJycsIGVsZW1lbnQubG9jKTtcbiAgICB9XG5cbiAgICBlbGVtZW50LmF0dHJpYnV0ZXMgPSBlbGVtZW50LmF0dHJpYnV0ZXMuc2xpY2UoMCwgYXNJbmRleCk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hpbGRyZW5Gb3Iobm9kZTogQVNULlByb2dyYW0gfCBBU1QuRWxlbWVudE5vZGUpOiBBU1QuU3RhdGVtZW50W10ge1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgJ1Byb2dyYW0nOiByZXR1cm4gbm9kZS5ib2R5O1xuICAgIGNhc2UgJ0VsZW1lbnROb2RlJzogcmV0dXJuIG5vZGUuY2hpbGRyZW47XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZENoaWxkKHBhcmVudDogQVNULlByb2dyYW0gfCBBU1QuRWxlbWVudE5vZGUsIG5vZGU6IEFTVC5TdGF0ZW1lbnQpIHtcbiAgY2hpbGRyZW5Gb3IocGFyZW50KS5wdXNoKG5vZGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNMaXRlcmFsKHBhdGg6IEFTVC5QYXRoRXhwcmVzc2lvbiB8IEFTVC5MaXRlcmFsKTogcGF0aCBpcyBBU1QuTGl0ZXJhbCB7XG4gIHJldHVybiBwYXRoLnR5cGUgPT09ICdTdHJpbmdMaXRlcmFsJ1xuICAgICAgfHwgcGF0aC50eXBlID09PSAnQm9vbGVhbkxpdGVyYWwnXG4gICAgICB8fCBwYXRoLnR5cGUgPT09ICdOdW1iZXJMaXRlcmFsJ1xuICAgICAgfHwgcGF0aC50eXBlID09PSAnTnVsbExpdGVyYWwnXG4gICAgICB8fCBwYXRoLnR5cGUgPT09ICdVbmRlZmluZWRMaXRlcmFsJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByaW50TGl0ZXJhbChsaXRlcmFsOiBBU1QuTGl0ZXJhbCk6IHN0cmluZyB7XG4gIGlmIChsaXRlcmFsLnR5cGUgPT09ICdVbmRlZmluZWRMaXRlcmFsJykge1xuICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobGl0ZXJhbC52YWx1ZSk7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIEV2ZW50ZWRUb2tlbml6ZXIsXG4gIEVudGl0eVBhcnNlcixcbiAgSFRNTDVOYW1lZENoYXJSZWZzIGFzIG5hbWVkQ2hhclJlZnNcbn0gZnJvbSBcInNpbXBsZS1odG1sLXRva2VuaXplclwiO1xuaW1wb3J0IHsgUHJvZ3JhbSB9IGZyb20gXCIuL3R5cGVzL25vZGVzXCI7XG5pbXBvcnQgKiBhcyBBU1QgZnJvbSBcIi4vdHlwZXMvbm9kZXNcIjtcbmltcG9ydCAqIGFzIEhhbmRsZWJhcnNBU1QgZnJvbSAnLi90eXBlcy9oYW5kbGViYXJzLWFzdCc7XG5pbXBvcnQgeyBPcHRpb24gfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGFzc2VydCwgZXhwZWN0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmNvbnN0IGVudGl0eVBhcnNlciA9IG5ldyBFbnRpdHlQYXJzZXIobmFtZWRDaGFyUmVmcyk7XG5cbmV4cG9ydCB0eXBlIEVsZW1lbnQgPSBBU1QuUHJvZ3JhbSB8IEFTVC5FbGVtZW50Tm9kZTtcblxuZXhwb3J0IGludGVyZmFjZSBUYWc8VCBleHRlbmRzICdTdGFydFRhZycgfCAnRW5kVGFnJz4ge1xuICB0eXBlOiBUO1xuICBuYW1lOiBzdHJpbmc7XG4gIGF0dHJpYnV0ZXM6IGFueVtdO1xuICBtb2RpZmllcnM6IGFueVtdO1xuICBjb21tZW50czogYW55W107XG4gIHNlbGZDbG9zaW5nOiBib29sZWFuO1xuICBsb2M6IEFTVC5Tb3VyY2VMb2NhdGlvbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdHRyaWJ1dGUge1xuICBuYW1lOiBzdHJpbmc7XG4gIHBhcnRzOiAoQVNULk11c3RhY2hlU3RhdGVtZW50IHwgQVNULlRleHROb2RlKVtdO1xuICBpc1F1b3RlZDogYm9vbGVhbjtcbiAgaXNEeW5hbWljOiBib29sZWFuO1xuICBzdGFydDogQVNULlBvc2l0aW9uO1xuICB2YWx1ZVN0YXJ0TGluZTogbnVtYmVyO1xuICB2YWx1ZVN0YXJ0Q29sdW1uOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBQYXJzZXIge1xuICBwcm90ZWN0ZWQgZWxlbWVudFN0YWNrOiBFbGVtZW50W10gPSBbXTtcbiAgcHJpdmF0ZSBvcHRpb25zOiBPYmplY3Q7XG4gIHByaXZhdGUgc291cmNlOiBzdHJpbmdbXTtcbiAgcHVibGljIGN1cnJlbnRBdHRyaWJ1dGU6IE9wdGlvbjxBdHRyaWJ1dGU+ID0gbnVsbDtcbiAgcHVibGljIGN1cnJlbnROb2RlOiBPcHRpb248QVNULkNvbW1lbnRTdGF0ZW1lbnQgfCBBU1QuVGV4dE5vZGUgfCBUYWc8J1N0YXJ0VGFnJyB8ICdFbmRUYWcnPj4gPSBudWxsO1xuICBwdWJsaWMgdG9rZW5pemVyID0gbmV3IEV2ZW50ZWRUb2tlbml6ZXIodGhpcywgZW50aXR5UGFyc2VyKTtcblxuICBjb25zdHJ1Y3Rvcihzb3VyY2U6IHN0cmluZywgb3B0aW9uczogT2JqZWN0ID0ge30pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgdGhpcy50b2tlbml6ZXIuc3RhdGVzLnRhZ09wZW4gPSBmdW5jdGlvbih0aGlzOiBFdmVudGVkVG9rZW5pemVyKSB7XG4gICAgICBsZXQgY2hhciA9IHRoaXMuY29uc3VtZSgpO1xuICAgICAgaWYgKGNoYXIgPT09IFwiIVwiKSB7XG4gICAgICAgIHRoaXNbJ3N0YXRlJ10gPSAnbWFya3VwRGVjbGFyYXRpb24nO1xuICAgICAgfSBlbHNlIGlmIChjaGFyID09PSBcIi9cIikge1xuICAgICAgICB0aGlzWydzdGF0ZSddID0gJ2VuZFRhZ09wZW4nO1xuICAgICAgfSBlbHNlIGlmICgvW0EtWmEtel0vLnRlc3QoY2hhcikpIHtcbiAgICAgICAgdGhpc1snc3RhdGUnXSA9ICd0YWdOYW1lJztcbiAgICAgICAgdGhpc1snZGVsZWdhdGUnXS5iZWdpblN0YXJ0VGFnKCk7XG4gICAgICAgIHRoaXNbJ2RlbGVnYXRlJ10uYXBwZW5kVG9UYWdOYW1lKGNoYXIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnRva2VuaXplci5zdGF0ZXMuZW5kVGFnT3BlbiA9IGZ1bmN0aW9uKHRoaXM6IEV2ZW50ZWRUb2tlbml6ZXIpIHtcbiAgICAgIGxldCBjaGFyID0gdGhpcy5jb25zdW1lKCk7XG4gICAgICBpZiAoL1tBLVphLXpdLy50ZXN0KGNoYXIpKSB7XG4gICAgICAgIHRoaXNbJ3N0YXRlJ10gPSAndGFnTmFtZSc7XG4gICAgICAgIHRoaXNbJ2RlbGVnYXRlJ10uYmVnaW5FbmRUYWcoKTtcbiAgICAgICAgdGhpc1snZGVsZWdhdGUnXS5hcHBlbmRUb1RhZ05hbWUoY2hhcik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuc291cmNlID0gc291cmNlLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG4gIH1cblxuICBnZXQgY3VycmVudEF0dHIoKTogQXR0cmlidXRlIHtcbiAgICByZXR1cm4gZXhwZWN0KHRoaXMuY3VycmVudEF0dHJpYnV0ZSwgJ2V4cGVjdGVkIGF0dHJpYnV0ZScpO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRUYWcoKTogVGFnPCdTdGFydFRhZycgfCAnRW5kVGFnJz4ge1xuICAgIGxldCBub2RlID0gdGhpcy5jdXJyZW50Tm9kZTtcbiAgICBhc3NlcnQobm9kZSAmJiAobm9kZS50eXBlID09PSAnU3RhcnRUYWcnIHx8IG5vZGUudHlwZSA9PT0gJ0VuZFRhZycpLCAnZXhwZWN0ZWQgdGFnJyk7XG4gICAgcmV0dXJuIG5vZGUgYXMgVGFnPCdTdGFydFRhZycgfCAnRW5kVGFnJz47XG4gIH1cblxuICBnZXQgY3VycmVudFN0YXJ0VGFnKCk6IFRhZzwnU3RhcnRUYWcnPiB7XG4gICAgbGV0IG5vZGUgPSB0aGlzLmN1cnJlbnROb2RlO1xuICAgIGFzc2VydChub2RlICYmIG5vZGUudHlwZSA9PT0gJ1N0YXJ0VGFnJywgJ2V4cGVjdGVkIHN0YXJ0IHRhZycpO1xuICAgIHJldHVybiBub2RlIGFzIFRhZzwnU3RhcnRUYWcnPjtcbiAgfVxuXG4gIGdldCBjdXJyZW50RW5kVGFnKCk6IFRhZzwnRW5kVGFnJz4ge1xuICAgIGxldCBub2RlID0gdGhpcy5jdXJyZW50Tm9kZTtcbiAgICBhc3NlcnQobm9kZSAmJiBub2RlLnR5cGUgPT09ICdFbmRUYWcnLCAnZXhwZWN0ZWQgZW5kIHRhZycpO1xuICAgIHJldHVybiBub2RlIGFzIFRhZzwnRW5kVGFnJz47XG4gIH1cblxuICBnZXQgY3VycmVudENvbW1lbnQoKTogQVNULkNvbW1lbnRTdGF0ZW1lbnQge1xuICAgIGxldCBub2RlID0gdGhpcy5jdXJyZW50Tm9kZTtcbiAgICBhc3NlcnQobm9kZSAmJiBub2RlLnR5cGUgPT09ICdDb21tZW50U3RhdGVtZW50JywgJ2V4cGVjdGVkIGEgY29tbWVudCcpO1xuICAgIHJldHVybiBub2RlIGFzIEFTVC5Db21tZW50U3RhdGVtZW50O1xuICB9XG5cbiAgZ2V0IGN1cnJlbnREYXRhKCk6IEFTVC5UZXh0Tm9kZSB7XG4gICAgbGV0IG5vZGUgPSB0aGlzLmN1cnJlbnROb2RlO1xuICAgIGFzc2VydChub2RlICYmIG5vZGUudHlwZSA9PT0gJ1RleHROb2RlJywgJ2V4cGVjdGVkIGEgdGV4dCBub2RlJyk7XG4gICAgcmV0dXJuIG5vZGUgYXMgQVNULlRleHROb2RlO1xuXG4gIH1cblxuICBhY2NlcHROb2RlKG5vZGU6IEhhbmRsZWJhcnNBU1QuUHJvZ3JhbSk6IFByb2dyYW07XG4gIGFjY2VwdE5vZGU8VSBleHRlbmRzIEFTVC5Ob2RlPihub2RlOiBIYW5kbGViYXJzQVNULk5vZGUpOiBVO1xuICBhY2NlcHROb2RlKG5vZGU6IEhhbmRsZWJhcnNBU1QuTm9kZSk6IGFueSB7XG4gICAgcmV0dXJuIHRoaXNbbm9kZS50eXBlXShub2RlKTtcbiAgfVxuXG4gIGN1cnJlbnRFbGVtZW50KCk6IEVsZW1lbnQge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRTdGFja1t0aGlzLmVsZW1lbnRTdGFjay5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIHNvdXJjZUZvck5vZGUobm9kZTogSGFuZGxlYmFyc0FTVC5Ob2RlLCBlbmROb2RlPzogeyBsb2M6IEhhbmRsZWJhcnNBU1QuU291cmNlTG9jYXRpb24gfSk6IHN0cmluZyB7XG4gICAgbGV0IGZpcnN0TGluZSA9IG5vZGUubG9jLnN0YXJ0LmxpbmUgLSAxO1xuICAgIGxldCBjdXJyZW50TGluZSA9IGZpcnN0TGluZSAtIDE7XG4gICAgbGV0IGZpcnN0Q29sdW1uID0gbm9kZS5sb2Muc3RhcnQuY29sdW1uO1xuICAgIGxldCBzdHJpbmcgPSBbXTtcbiAgICBsZXQgbGluZTtcblxuICAgIGxldCBsYXN0TGluZTogbnVtYmVyO1xuICAgIGxldCBsYXN0Q29sdW1uOiBudW1iZXI7XG5cbiAgICBpZiAoZW5kTm9kZSkge1xuICAgICAgbGFzdExpbmUgPSBlbmROb2RlLmxvYy5lbmQubGluZSAtIDE7XG4gICAgICBsYXN0Q29sdW1uID0gZW5kTm9kZS5sb2MuZW5kLmNvbHVtbjtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdExpbmUgPSBub2RlLmxvYy5lbmQubGluZSAtIDE7XG4gICAgICBsYXN0Q29sdW1uID0gbm9kZS5sb2MuZW5kLmNvbHVtbjtcbiAgICB9XG5cbiAgICB3aGlsZSAoY3VycmVudExpbmUgPCBsYXN0TGluZSkge1xuICAgICAgY3VycmVudExpbmUrKztcbiAgICAgIGxpbmUgPSB0aGlzLnNvdXJjZVtjdXJyZW50TGluZV07XG5cbiAgICAgIGlmIChjdXJyZW50TGluZSA9PT0gZmlyc3RMaW5lKSB7XG4gICAgICAgIGlmIChmaXJzdExpbmUgPT09IGxhc3RMaW5lKSB7XG4gICAgICAgICAgc3RyaW5nLnB1c2gobGluZS5zbGljZShmaXJzdENvbHVtbiwgbGFzdENvbHVtbikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmluZy5wdXNoKGxpbmUuc2xpY2UoZmlyc3RDb2x1bW4pKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjdXJyZW50TGluZSA9PT0gbGFzdExpbmUpIHtcbiAgICAgICAgc3RyaW5nLnB1c2gobGluZS5zbGljZSgwLCBsYXN0Q29sdW1uKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJpbmcucHVzaChsaW5lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5nLmpvaW4oJ1xcbicpO1xuICB9XG59XG4iLCJpbXBvcnQgYiBmcm9tIFwiLi4vYnVpbGRlcnNcIjtcbmltcG9ydCB7IGFwcGVuZENoaWxkLCBpc0xpdGVyYWwsIHByaW50TGl0ZXJhbCB9IGZyb20gXCIuLi91dGlsc1wiO1xuaW1wb3J0ICogYXMgQVNUIGZyb20gJy4uL3R5cGVzL25vZGVzJztcbmltcG9ydCAqIGFzIEhhbmRsZWJhcnNBU1QgZnJvbSAnLi4vdHlwZXMvaGFuZGxlYmFycy1hc3QnO1xuaW1wb3J0IHsgUGFyc2VyLCBUYWcsIEF0dHJpYnV0ZSB9IGZyb20gJy4uL3BhcnNlcic7XG5pbXBvcnQgU3ludGF4RXJyb3IgZnJvbSAnLi4vZXJyb3JzL3N5bnRheC1lcnJvcic7XG5pbXBvcnQgeyBPcHRpb24gfSBmcm9tIFwiQGdsaW1tZXIvdXRpbFwiO1xuaW1wb3J0IHsgUmVjYXN0IH0gZnJvbSBcIkBnbGltbWVyL2ludGVyZmFjZXNcIjtcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEhhbmRsZWJhcnNOb2RlVmlzaXRvcnMgZXh0ZW5kcyBQYXJzZXIge1xuICBhYnN0cmFjdCBhcHBlbmRUb0NvbW1lbnREYXRhKHM6IHN0cmluZyk6IHZvaWQ7XG4gIGFic3RyYWN0IGJlZ2luQXR0cmlidXRlVmFsdWUocXVvdGVkOiBib29sZWFuKTogdm9pZDtcbiAgYWJzdHJhY3QgZmluaXNoQXR0cmlidXRlVmFsdWUoKTogdm9pZDtcblxuICBjdXJzb3JDb3VudCA9IDA7XG5cbiAgY3Vyc29yKCkge1xuICAgIHJldHVybiBgJWN1cnNvcjoke3RoaXMuY3Vyc29yQ291bnQrK30lYDtcbiAgfVxuXG4gIFByb2dyYW0ocHJvZ3JhbTogSGFuZGxlYmFyc0FTVC5Qcm9ncmFtKTogQVNULlByb2dyYW0ge1xuICAgIGxldCBib2R5OiBBU1QuU3RhdGVtZW50W10gPSBbXTtcbiAgICB0aGlzLmN1cnNvckNvdW50ID0gMDtcbiAgICBsZXQgbm9kZSA9IGIucHJvZ3JhbShib2R5LCBwcm9ncmFtLmJsb2NrUGFyYW1zLCBwcm9ncmFtLmxvYyk7XG4gICAgbGV0IGksIGwgPSBwcm9ncmFtLmJvZHkubGVuZ3RoO1xuXG4gICAgdGhpcy5lbGVtZW50U3RhY2sucHVzaChub2RlKTtcblxuICAgIGlmIChsID09PSAwKSB7IHJldHVybiB0aGlzLmVsZW1lbnRTdGFjay5wb3AoKSBhcyBBU1QuUHJvZ3JhbTsgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5hY2NlcHROb2RlKHByb2dyYW0uYm9keVtpXSk7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhhdCB0aGUgZWxlbWVudCBzdGFjayBpcyBiYWxhbmNlZCBwcm9wZXJseS5cbiAgICBsZXQgcG9wcGVkTm9kZSA9IHRoaXMuZWxlbWVudFN0YWNrLnBvcCgpO1xuICAgIGlmIChwb3BwZWROb2RlICE9PSBub2RlKSB7XG4gICAgICBsZXQgZWxlbWVudE5vZGUgPSBwb3BwZWROb2RlIGFzIEFTVC5FbGVtZW50Tm9kZTtcblxuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVW5jbG9zZWQgZWxlbWVudCBgXCIgKyBlbGVtZW50Tm9kZS50YWcgKyBcImAgKG9uIGxpbmUgXCIgKyBlbGVtZW50Tm9kZS5sb2MhLnN0YXJ0LmxpbmUgKyBcIikuXCIsIGVsZW1lbnROb2RlLmxvYyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBCbG9ja1N0YXRlbWVudChibG9jazogSGFuZGxlYmFyc0FTVC5CbG9ja1N0YXRlbWVudCkge1xuICAgIGlmICh0aGlzLnRva2VuaXplclsnc3RhdGUnXSA9PT0gJ2NvbW1lbnQnKSB7XG4gICAgICB0aGlzLmFwcGVuZFRvQ29tbWVudERhdGEodGhpcy5zb3VyY2VGb3JOb2RlKGJsb2NrKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudG9rZW5pemVyWydzdGF0ZSddICE9PSAnY29tbWVudCcgJiYgdGhpcy50b2tlbml6ZXJbJ3N0YXRlJ10gIT09ICdkYXRhJyAmJiB0aGlzLnRva2VuaXplclsnc3RhdGUnXSAhPT0gJ2JlZm9yZURhdGEnKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJBIGJsb2NrIG1heSBvbmx5IGJlIHVzZWQgaW5zaWRlIGFuIEhUTUwgZWxlbWVudCBvciBhbm90aGVyIGJsb2NrLlwiLCBibG9jay5sb2MpO1xuICAgIH1cblxuICAgIGxldCB7IHBhdGgsIHBhcmFtcywgaGFzaCB9ID0gYWNjZXB0Q2FsbE5vZGVzKHRoaXMsIGJsb2NrKTtcbiAgICBsZXQgcHJvZ3JhbSA9IHRoaXMuUHJvZ3JhbShibG9jay5wcm9ncmFtKTtcbiAgICBsZXQgaW52ZXJzZSA9IGJsb2NrLmludmVyc2UgPyB0aGlzLlByb2dyYW0oYmxvY2suaW52ZXJzZSkgOiBudWxsO1xuXG4gICAgaWYocGF0aC5vcmlnaW5hbCA9PT0gJ2luLWVsZW1lbnQnKSB7XG4gICAgICBoYXNoID0gYWRkSW5FbGVtZW50SGFzaCh0aGlzLmN1cnNvcigpLCBoYXNoLCBibG9jay5sb2MpO1xuICAgIH1cblxuICAgIGxldCBub2RlID0gYi5ibG9jayhwYXRoLCBwYXJhbXMsIGhhc2gsIHByb2dyYW0sIGludmVyc2UsIGJsb2NrLmxvYyk7XG5cbiAgICBsZXQgcGFyZW50UHJvZ3JhbSA9IHRoaXMuY3VycmVudEVsZW1lbnQoKTtcbiAgICBhcHBlbmRDaGlsZChwYXJlbnRQcm9ncmFtLCBub2RlKTtcbiAgfVxuXG4gIE11c3RhY2hlU3RhdGVtZW50KHJhd011c3RhY2hlOiBIYW5kbGViYXJzQVNULk11c3RhY2hlU3RhdGVtZW50KSB7XG4gICAgbGV0IHsgdG9rZW5pemVyIH0gPSB0aGlzO1xuXG4gICAgaWYgKHRva2VuaXplclsnc3RhdGUnXSA9PT0gJ2NvbW1lbnQnKSB7XG4gICAgICB0aGlzLmFwcGVuZFRvQ29tbWVudERhdGEodGhpcy5zb3VyY2VGb3JOb2RlKHJhd011c3RhY2hlKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IG11c3RhY2hlOiBBU1QuTXVzdGFjaGVTdGF0ZW1lbnQ7XG4gICAgbGV0IHsgZXNjYXBlZCwgbG9jIH0gPSByYXdNdXN0YWNoZTtcblxuICAgIGlmIChyYXdNdXN0YWNoZS5wYXRoLnR5cGUubWF0Y2goL0xpdGVyYWwkLykpIHtcbiAgICAgIG11c3RhY2hlID0ge1xuICAgICAgICB0eXBlOiAnTXVzdGFjaGVTdGF0ZW1lbnQnLFxuICAgICAgICBwYXRoOiB0aGlzLmFjY2VwdE5vZGU8QVNULkxpdGVyYWw+KHJhd011c3RhY2hlLnBhdGgpLFxuICAgICAgICBwYXJhbXM6IFtdLFxuICAgICAgICBoYXNoOiBiLmhhc2goKSxcbiAgICAgICAgZXNjYXBlZCxcbiAgICAgICAgbG9jXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgeyBwYXRoLCBwYXJhbXMsIGhhc2ggfSA9IGFjY2VwdENhbGxOb2Rlcyh0aGlzLCByYXdNdXN0YWNoZSBhcyBIYW5kbGViYXJzQVNULk11c3RhY2hlU3RhdGVtZW50ICYgeyBwYXRoOiBIYW5kbGViYXJzQVNULlBhdGhFeHByZXNzaW9uIH0pO1xuICAgICAgbXVzdGFjaGUgPSBiLm11c3RhY2hlKHBhdGgsIHBhcmFtcywgaGFzaCwgIWVzY2FwZWQsIGxvYyk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0b2tlbml6ZXJbJ3N0YXRlJ10pIHtcbiAgICAgIC8vIFRhZyBoZWxwZXJzXG4gICAgICBjYXNlIFwidGFnTmFtZVwiOlxuICAgICAgICBhZGRFbGVtZW50TW9kaWZpZXIodGhpcy5jdXJyZW50U3RhcnRUYWcsIG11c3RhY2hlKTtcbiAgICAgICAgdG9rZW5pemVyWydzdGF0ZSddID0gXCJiZWZvcmVBdHRyaWJ1dGVOYW1lXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJlZm9yZUF0dHJpYnV0ZU5hbWVcIjpcbiAgICAgICAgYWRkRWxlbWVudE1vZGlmaWVyKHRoaXMuY3VycmVudFN0YXJ0VGFnLCBtdXN0YWNoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImF0dHJpYnV0ZU5hbWVcIjpcbiAgICAgIGNhc2UgXCJhZnRlckF0dHJpYnV0ZU5hbWVcIjpcbiAgICAgICAgdGhpcy5iZWdpbkF0dHJpYnV0ZVZhbHVlKGZhbHNlKTtcbiAgICAgICAgdGhpcy5maW5pc2hBdHRyaWJ1dGVWYWx1ZSgpO1xuICAgICAgICBhZGRFbGVtZW50TW9kaWZpZXIodGhpcy5jdXJyZW50U3RhcnRUYWcsIG11c3RhY2hlKTtcbiAgICAgICAgdG9rZW5pemVyWydzdGF0ZSddID0gXCJiZWZvcmVBdHRyaWJ1dGVOYW1lXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImFmdGVyQXR0cmlidXRlVmFsdWVRdW90ZWRcIjpcbiAgICAgICAgYWRkRWxlbWVudE1vZGlmaWVyKHRoaXMuY3VycmVudFN0YXJ0VGFnLCBtdXN0YWNoZSk7XG4gICAgICAgIHRva2VuaXplclsnc3RhdGUnXSA9IFwiYmVmb3JlQXR0cmlidXRlTmFtZVwiO1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gQXR0cmlidXRlIHZhbHVlc1xuICAgICAgY2FzZSBcImJlZm9yZUF0dHJpYnV0ZVZhbHVlXCI6XG4gICAgICAgIHRoaXMuYmVnaW5BdHRyaWJ1dGVWYWx1ZShmYWxzZSk7XG4gICAgICAgIGFwcGVuZER5bmFtaWNBdHRyaWJ1dGVWYWx1ZVBhcnQodGhpcy5jdXJyZW50QXR0cmlidXRlISwgbXVzdGFjaGUpO1xuICAgICAgICB0b2tlbml6ZXJbJ3N0YXRlJ10gPSAnYXR0cmlidXRlVmFsdWVVbnF1b3RlZCc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImF0dHJpYnV0ZVZhbHVlRG91YmxlUXVvdGVkXCI6XG4gICAgICBjYXNlIFwiYXR0cmlidXRlVmFsdWVTaW5nbGVRdW90ZWRcIjpcbiAgICAgIGNhc2UgXCJhdHRyaWJ1dGVWYWx1ZVVucXVvdGVkXCI6XG4gICAgICAgIGFwcGVuZER5bmFtaWNBdHRyaWJ1dGVWYWx1ZVBhcnQodGhpcy5jdXJyZW50QXR0cmlidXRlISwgbXVzdGFjaGUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gVE9ETzogT25seSBhcHBlbmQgY2hpbGQgd2hlbiB0aGUgdG9rZW5pemVyIHN0YXRlIG1ha2VzXG4gICAgICAvLyBzZW5zZSB0byBkbyBzbywgb3RoZXJ3aXNlIHRocm93IGFuIGVycm9yLlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXBwZW5kQ2hpbGQodGhpcy5jdXJyZW50RWxlbWVudCgpLCBtdXN0YWNoZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG11c3RhY2hlO1xuICB9XG5cbiAgQ29udGVudFN0YXRlbWVudChjb250ZW50OiBIYW5kbGViYXJzQVNULkNvbnRlbnRTdGF0ZW1lbnQpIHtcbiAgICB1cGRhdGVUb2tlbml6ZXJMb2NhdGlvbih0aGlzLnRva2VuaXplciwgY29udGVudCk7XG5cbiAgICB0aGlzLnRva2VuaXplci50b2tlbml6ZVBhcnQoY29udGVudC52YWx1ZSk7XG4gICAgdGhpcy50b2tlbml6ZXIuZmx1c2hEYXRhKCk7XG4gIH1cblxuICBDb21tZW50U3RhdGVtZW50KHJhd0NvbW1lbnQ6IEhhbmRsZWJhcnNBU1QuQ29tbWVudFN0YXRlbWVudCk6IE9wdGlvbjxBU1QuTXVzdGFjaGVDb21tZW50U3RhdGVtZW50PiB7XG4gICAgbGV0IHsgdG9rZW5pemVyIH0gPSB0aGlzO1xuXG4gICAgaWYgKHRva2VuaXplclsnc3RhdGUnXSA9PT0gJ2NvbW1lbnQnKSB7XG4gICAgICB0aGlzLmFwcGVuZFRvQ29tbWVudERhdGEodGhpcy5zb3VyY2VGb3JOb2RlKHJhd0NvbW1lbnQpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCB7IHZhbHVlLCBsb2MgfSA9IHJhd0NvbW1lbnQ7XG4gICAgbGV0IGNvbW1lbnQgPSBiLm11c3RhY2hlQ29tbWVudCh2YWx1ZSwgbG9jKTtcblxuICAgIHN3aXRjaCAodG9rZW5pemVyWydzdGF0ZSddKSB7XG4gICAgICBjYXNlIFwiYmVmb3JlQXR0cmlidXRlTmFtZVwiOlxuICAgICAgICB0aGlzLmN1cnJlbnRTdGFydFRhZy5jb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYmVmb3JlRGF0YSc6XG4gICAgICBjYXNlICdkYXRhJzpcbiAgICAgICAgYXBwZW5kQ2hpbGQodGhpcy5jdXJyZW50RWxlbWVudCgpLCBjb21tZW50KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVXNpbmcgYSBIYW5kbGViYXJzIGNvbW1lbnQgd2hlbiBpbiB0aGUgXFxgJHt0b2tlbml6ZXJbJ3N0YXRlJ119XFxgIHN0YXRlIGlzIG5vdCBzdXBwb3J0ZWQ6IFwiJHtjb21tZW50LnZhbHVlfVwiIG9uIGxpbmUgJHtsb2Muc3RhcnQubGluZX06JHtsb2Muc3RhcnQuY29sdW1ufWAsIHJhd0NvbW1lbnQubG9jKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tbWVudDtcbiAgfVxuXG4gIFBhcnRpYWxTdGF0ZW1lbnQocGFydGlhbDogSGFuZGxlYmFyc0FTVC5QYXJ0aWFsU3RhdGVtZW50KSB7XG4gICAgbGV0IHsgbG9jIH0gPSBwYXJ0aWFsO1xuXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBIYW5kbGViYXJzIHBhcnRpYWxzIGFyZSBub3Qgc3VwcG9ydGVkOiBcIiR7dGhpcy5zb3VyY2VGb3JOb2RlKHBhcnRpYWwsIHBhcnRpYWwubmFtZSl9XCIgYXQgTCR7bG9jLnN0YXJ0LmxpbmV9OkMke2xvYy5zdGFydC5jb2x1bW59YCwgcGFydGlhbC5sb2MpO1xuICB9XG5cbiAgUGFydGlhbEJsb2NrU3RhdGVtZW50KHBhcnRpYWxCbG9jazogSGFuZGxlYmFyc0FTVC5QYXJ0aWFsQmxvY2tTdGF0ZW1lbnQpIHtcbiAgICBsZXQgeyBsb2MgfSA9IHBhcnRpYWxCbG9jaztcblxuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSGFuZGxlYmFycyBwYXJ0aWFsIGJsb2NrcyBhcmUgbm90IHN1cHBvcnRlZDogXCIke3RoaXMuc291cmNlRm9yTm9kZShwYXJ0aWFsQmxvY2ssIHBhcnRpYWxCbG9jay5uYW1lKX1cIiBhdCBMJHtsb2Muc3RhcnQubGluZX06QyR7bG9jLnN0YXJ0LmNvbHVtbn1gLCBwYXJ0aWFsQmxvY2subG9jKTtcbiAgfVxuXG4gIERlY29yYXRvcihkZWNvcmF0b3I6IEhhbmRsZWJhcnNBU1QuRGVjb3JhdG9yKSB7XG4gICAgbGV0IHsgbG9jIH0gPSBkZWNvcmF0b3I7XG5cbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEhhbmRsZWJhcnMgZGVjb3JhdG9ycyBhcmUgbm90IHN1cHBvcnRlZDogXCIke3RoaXMuc291cmNlRm9yTm9kZShkZWNvcmF0b3IsIGRlY29yYXRvci5wYXRoKX1cIiBhdCBMJHtsb2Muc3RhcnQubGluZX06QyR7bG9jLnN0YXJ0LmNvbHVtbn1gLCBkZWNvcmF0b3IubG9jKTtcbiAgfVxuXG4gIERlY29yYXRvckJsb2NrKGRlY29yYXRvckJsb2NrOiBIYW5kbGViYXJzQVNULkRlY29yYXRvckJsb2NrKSB7XG4gICAgbGV0IHsgbG9jIH0gPSBkZWNvcmF0b3JCbG9jaztcblxuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSGFuZGxlYmFycyBkZWNvcmF0b3IgYmxvY2tzIGFyZSBub3Qgc3VwcG9ydGVkOiBcIiR7dGhpcy5zb3VyY2VGb3JOb2RlKGRlY29yYXRvckJsb2NrLCBkZWNvcmF0b3JCbG9jay5wYXRoKX1cIiBhdCBMJHtsb2Muc3RhcnQubGluZX06QyR7bG9jLnN0YXJ0LmNvbHVtbn1gLCBkZWNvcmF0b3JCbG9jay5sb2MpO1xuICB9XG5cbiAgU3ViRXhwcmVzc2lvbihzZXhwcjogSGFuZGxlYmFyc0FTVC5TdWJFeHByZXNzaW9uKTogQVNULlN1YkV4cHJlc3Npb24ge1xuICAgIGxldCB7IHBhdGgsIHBhcmFtcywgaGFzaCB9ID0gYWNjZXB0Q2FsbE5vZGVzKHRoaXMsIHNleHByKTtcbiAgICByZXR1cm4gYi5zZXhwcihwYXRoLCBwYXJhbXMsIGhhc2gsIHNleHByLmxvYyk7XG4gIH1cblxuICBQYXRoRXhwcmVzc2lvbihwYXRoOiBIYW5kbGViYXJzQVNULlBhdGhFeHByZXNzaW9uKTogQVNULlBhdGhFeHByZXNzaW9uIHtcbiAgICBsZXQgeyBvcmlnaW5hbCwgbG9jIH0gPSBwYXRoO1xuICAgIGxldCBwYXJ0czogc3RyaW5nW107XG5cbiAgICBpZiAob3JpZ2luYWwuaW5kZXhPZignLycpICE9PSAtMSkge1xuICAgICAgaWYgKG9yaWdpbmFsLnNsaWNlKDAsIDIpID09PSAnLi8nKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVXNpbmcgXCIuL1wiIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2xpbW1lciBhbmQgdW5uZWNlc3Nhcnk6IFwiJHtwYXRoLm9yaWdpbmFsfVwiIG9uIGxpbmUgJHtsb2Muc3RhcnQubGluZX0uYCwgcGF0aC5sb2MpO1xuICAgICAgfVxuICAgICAgaWYgKG9yaWdpbmFsLnNsaWNlKDAsIDMpID09PSAnLi4vJykge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYENoYW5naW5nIGNvbnRleHQgdXNpbmcgXCIuLi9cIiBpcyBub3Qgc3VwcG9ydGVkIGluIEdsaW1tZXI6IFwiJHtwYXRoLm9yaWdpbmFsfVwiIG9uIGxpbmUgJHtsb2Muc3RhcnQubGluZX0uYCwgcGF0aC5sb2MpO1xuICAgICAgfVxuICAgICAgaWYgKG9yaWdpbmFsLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBNaXhpbmcgJy4nIGFuZCAnLycgaW4gcGF0aHMgaXMgbm90IHN1cHBvcnRlZCBpbiBHbGltbWVyOyB1c2Ugb25seSAnLicgdG8gc2VwYXJhdGUgcHJvcGVydHkgcGF0aHM6IFwiJHtwYXRoLm9yaWdpbmFsfVwiIG9uIGxpbmUgJHtsb2Muc3RhcnQubGluZX0uYCwgcGF0aC5sb2MpO1xuICAgICAgfVxuICAgICAgcGFydHMgPSBbIHBhdGgucGFydHMuam9pbignLycpIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnRzID0gcGF0aC5wYXJ0cztcbiAgICB9XG5cbiAgICBsZXQgdGhpc0hlYWQgPSBmYWxzZTtcblxuICAgIC8vIFRoaXMgaXMgdG8gZml4IGEgYnVnIGluIHRoZSBIYW5kbGViYXJzIEFTVCB3aGVyZSB0aGUgcGF0aCBleHByZXNzaW9ucyBpblxuICAgIC8vIGB7e3RoaXMuZm9vfX1gIChhbmQgc2ltaWxhcmx5IGB7e2Zvby1iYXIgdGhpcy5mb28gbmFtZWQ9dGhpcy5mb299fWAgZXRjKVxuICAgIC8vIGFyZSBzaW1wbHkgdHVybmVkIGludG8gYHt7Zm9vfX1gLiBUaGUgZml4IGlzIHRvIHB1c2ggaXQgYmFjayBvbnRvIHRoZVxuICAgIC8vIHBhcnRzIGFycmF5IGFuZCBsZXQgdGhlIHJ1bnRpbWUgc2VlIHRoZSBkaWZmZXJlbmNlLiBIb3dldmVyLCB3ZSBjYW5ub3RcbiAgICAvLyBzaW1wbHkgdXNlIHRoZSBzdHJpbmcgYHRoaXNgIGFzIGl0IG1lYW5zIGxpdGVyYWxseSB0aGUgcHJvcGVydHkgY2FsbGVkXG4gICAgLy8gXCJ0aGlzXCIgaW4gdGhlIGN1cnJlbnQgY29udGV4dCAoaXQgY2FuIGJlIGV4cHJlc3NlZCBpbiB0aGUgc3ludGF4IGFzXG4gICAgLy8gYHt7W3RoaXNdfX1gLCB3aGVyZSB0aGUgc3F1YXJlIGJyYWNrZXQgYXJlIGdlbmVyYWxseSBmb3IgdGhpcyBraW5kIG9mXG4gICAgLy8gZXNjYXBpbmcgw6LCgMKTIHN1Y2ggYXMgYHt7Zm9vLltcImJhci5iYXpcIl19fWAgd291bGQgbWVhbiBsb29rdXAgYSBwcm9wZXJ0eVxuICAgIC8vIG5hbWVkIGxpdGVyYWxseSBcImJhci5iYXpcIiBvbiBgdGhpcy5mb29gKS4gQnkgY29udmVudGlvbiwgd2UgdXNlIGBudWxsYFxuICAgIC8vIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgaWYgKG9yaWdpbmFsLm1hdGNoKC9edGhpcyhcXC4uKyk/JC8pKSB7XG4gICAgICB0aGlzSGVhZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdQYXRoRXhwcmVzc2lvbicsXG4gICAgICBvcmlnaW5hbDogcGF0aC5vcmlnaW5hbCxcbiAgICAgIHRoaXM6IHRoaXNIZWFkLFxuICAgICAgcGFydHMsXG4gICAgICBkYXRhOiBwYXRoLmRhdGEsXG4gICAgICBsb2M6IHBhdGgubG9jXG4gICAgfTtcbiAgfVxuXG4gIEhhc2goaGFzaDogSGFuZGxlYmFyc0FTVC5IYXNoKTogQVNULkhhc2gge1xuICAgIGxldCBwYWlyczogQVNULkhhc2hQYWlyW10gPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGFzaC5wYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHBhaXIgPSBoYXNoLnBhaXJzW2ldO1xuICAgICAgcGFpcnMucHVzaChiLnBhaXIocGFpci5rZXksIHRoaXMuYWNjZXB0Tm9kZTxBU1QuRXhwcmVzc2lvbj4ocGFpci52YWx1ZSksIHBhaXIubG9jKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGIuaGFzaChwYWlycywgaGFzaC5sb2MpO1xuICB9XG5cbiAgU3RyaW5nTGl0ZXJhbChzdHJpbmc6IEhhbmRsZWJhcnNBU1QuU3RyaW5nTGl0ZXJhbCkge1xuICAgIHJldHVybiBiLmxpdGVyYWwoJ1N0cmluZ0xpdGVyYWwnLCBzdHJpbmcudmFsdWUsIHN0cmluZy5sb2MpO1xuICB9XG5cbiAgQm9vbGVhbkxpdGVyYWwoYm9vbGVhbjogSGFuZGxlYmFyc0FTVC5Cb29sZWFuTGl0ZXJhbCkge1xuICAgIHJldHVybiBiLmxpdGVyYWwoJ0Jvb2xlYW5MaXRlcmFsJywgYm9vbGVhbi52YWx1ZSwgYm9vbGVhbi5sb2MpO1xuICB9XG5cbiAgTnVtYmVyTGl0ZXJhbChudW1iZXI6IEhhbmRsZWJhcnNBU1QuTnVtYmVyTGl0ZXJhbCkge1xuICAgIHJldHVybiBiLmxpdGVyYWwoJ051bWJlckxpdGVyYWwnLCBudW1iZXIudmFsdWUsIG51bWJlci5sb2MpO1xuICB9XG5cbiAgVW5kZWZpbmVkTGl0ZXJhbCh1bmRlZjogSGFuZGxlYmFyc0FTVC5VbmRlZmluZWRMaXRlcmFsKSB7XG4gICAgcmV0dXJuIGIubGl0ZXJhbCgnVW5kZWZpbmVkTGl0ZXJhbCcsIHVuZGVmaW5lZCwgdW5kZWYubG9jKTtcbiAgfVxuXG4gIE51bGxMaXRlcmFsKG51bDogSGFuZGxlYmFyc0FTVC5OdWxsTGl0ZXJhbCkge1xuICAgIHJldHVybiBiLmxpdGVyYWwoJ051bGxMaXRlcmFsJywgbnVsbCwgbnVsLmxvYyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUmlnaHRTdHJpcHBlZE9mZnNldHMob3JpZ2luYWw6IHN0cmluZywgdmFsdWU6IHN0cmluZykge1xuICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgLy8gaWYgaXQgaXMgZW1wdHksIGp1c3QgcmV0dXJuIHRoZSBjb3VudCBvZiBuZXdsaW5lc1xuICAgIC8vIGluIG9yaWdpbmFsXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmVzOiBvcmlnaW5hbC5zcGxpdChcIlxcblwiKS5sZW5ndGggLSAxLFxuICAgICAgY29sdW1uczogMFxuICAgIH07XG4gIH1cblxuICAvLyBvdGhlcndpc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIG5ld2xpbmVzIHByaW9yIHRvXG4gIC8vIGB2YWx1ZWBcbiAgbGV0IGRpZmZlcmVuY2UgPSBvcmlnaW5hbC5zcGxpdCh2YWx1ZSlbMF07XG4gIGxldCBsaW5lcyA9IGRpZmZlcmVuY2Uuc3BsaXQoL1xcbi8pO1xuICBsZXQgbGluZUNvdW50ID0gbGluZXMubGVuZ3RoIC0gMTtcblxuICByZXR1cm4ge1xuICAgIGxpbmVzOiBsaW5lQ291bnQsXG4gICAgY29sdW1uczogbGluZXNbbGluZUNvdW50XS5sZW5ndGhcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlVG9rZW5pemVyTG9jYXRpb24odG9rZW5pemVyOiBQYXJzZXJbJ3Rva2VuaXplciddLCBjb250ZW50OiBIYW5kbGViYXJzQVNULkNvbnRlbnRTdGF0ZW1lbnQpIHtcbiAgbGV0IGxpbmUgPSBjb250ZW50LmxvYy5zdGFydC5saW5lO1xuICBsZXQgY29sdW1uID0gY29udGVudC5sb2Muc3RhcnQuY29sdW1uO1xuXG4gIGxldCBvZmZzZXRzID0gY2FsY3VsYXRlUmlnaHRTdHJpcHBlZE9mZnNldHMoY29udGVudC5vcmlnaW5hbCBhcyBSZWNhc3Q8SGFuZGxlYmFyc0FTVC5TdHJpcEZsYWdzLCBzdHJpbmc+LCBjb250ZW50LnZhbHVlKTtcblxuICBsaW5lID0gbGluZSArIG9mZnNldHMubGluZXM7XG4gIGlmIChvZmZzZXRzLmxpbmVzKSB7XG4gICAgY29sdW1uID0gb2Zmc2V0cy5jb2x1bW5zO1xuICB9IGVsc2Uge1xuICAgIGNvbHVtbiA9IGNvbHVtbiArIG9mZnNldHMuY29sdW1ucztcbiAgfVxuXG4gIHRva2VuaXplci5saW5lID0gbGluZTtcbiAgdG9rZW5pemVyLmNvbHVtbiA9IGNvbHVtbjtcbn1cblxuZnVuY3Rpb24gYWNjZXB0Q2FsbE5vZGVzKGNvbXBpbGVyOiBIYW5kbGViYXJzTm9kZVZpc2l0b3JzLCBub2RlOiB7IHBhdGg6IEhhbmRsZWJhcnNBU1QuUGF0aEV4cHJlc3Npb24sIHBhcmFtczogSGFuZGxlYmFyc0FTVC5FeHByZXNzaW9uW10sIGhhc2g6IEhhbmRsZWJhcnNBU1QuSGFzaCB9KTogeyBwYXRoOiBBU1QuUGF0aEV4cHJlc3Npb24sIHBhcmFtczogQVNULkV4cHJlc3Npb25bXSwgaGFzaDogQVNULkhhc2ggfSB7XG4gIGxldCBwYXRoID0gY29tcGlsZXIuUGF0aEV4cHJlc3Npb24obm9kZS5wYXRoKTtcblxuICBsZXQgcGFyYW1zID0gbm9kZS5wYXJhbXMgPyBub2RlLnBhcmFtcy5tYXAoZSA9PiBjb21waWxlci5hY2NlcHROb2RlPEFTVC5FeHByZXNzaW9uPihlKSkgOiBbXTtcbiAgbGV0IGhhc2ggPSBub2RlLmhhc2ggPyBjb21waWxlci5IYXNoKG5vZGUuaGFzaCkgOiBiLmhhc2goKTtcblxuICByZXR1cm4geyBwYXRoLCBwYXJhbXMsIGhhc2ggfTtcbn1cblxuZnVuY3Rpb24gYWRkRWxlbWVudE1vZGlmaWVyKGVsZW1lbnQ6IFRhZzwnU3RhcnRUYWcnPiwgbXVzdGFjaGU6IEFTVC5NdXN0YWNoZVN0YXRlbWVudCkge1xuICBsZXQgeyBwYXRoLCBwYXJhbXMsIGhhc2gsIGxvYyB9ID0gbXVzdGFjaGU7XG5cbiAgaWYgKGlzTGl0ZXJhbChwYXRoKSkge1xuICAgIGxldCBtb2RpZmllciA9IGB7eyR7cHJpbnRMaXRlcmFsKHBhdGgpfX19YDtcbiAgICBsZXQgdGFnID0gYDwke2VsZW1lbnQubmFtZX0gLi4uICR7bW9kaWZpZXJ9IC4uLmA7XG5cbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEluICR7dGFnfSwgJHttb2RpZmllcn0gaXMgbm90IGEgdmFsaWQgbW9kaWZpZXI6IFwiJHtwYXRoLm9yaWdpbmFsfVwiIG9uIGxpbmUgJHtsb2MgJiYgbG9jLnN0YXJ0LmxpbmV9LmAsIG11c3RhY2hlLmxvYyk7XG4gIH1cblxuICBsZXQgbW9kaWZpZXIgPSBiLmVsZW1lbnRNb2RpZmllcihwYXRoLCBwYXJhbXMsIGhhc2gsIGxvYyk7XG4gIGVsZW1lbnQubW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xufVxuXG5mdW5jdGlvbiBhZGRJbkVsZW1lbnRIYXNoKGN1cnNvcjogc3RyaW5nLCBoYXNoOiBBU1QuSGFzaCwgbG9jOiBBU1QuU291cmNlTG9jYXRpb24pIHtcbiAgbGV0IGhhc05leHRTaWJsaW5nID0gZmFsc2U7XG4gIGhhc2gucGFpcnMuZm9yRWFjaCgocGFpcikgPT4ge1xuICAgIGlmIChwYWlyLmtleSA9PT0gJ2d1aWQnKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0Nhbm5vdCBwYXNzIGBndWlkYCBmcm9tIHVzZXIgc3BhY2UnLCBsb2MpO1xuICAgIH1cblxuICAgIGlmIChwYWlyLmtleSA9PT0gJ25leHRTaWJsaW5nJykge1xuICAgICAgaGFzTmV4dFNpYmxpbmcgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgbGV0IGd1aWQgPSBiLmxpdGVyYWwoJ1N0cmluZ0xpdGVyYWwnLCBjdXJzb3IpO1xuICBsZXQgZ3VpZFBhaXIgPSBiLnBhaXIoJ2d1aWQnLCBndWlkKTtcbiAgaGFzaC5wYWlycy51bnNoaWZ0KGd1aWRQYWlyKTtcblxuICBpZiAoIWhhc05leHRTaWJsaW5nKSB7XG4gICAgbGV0IG51bGxMaXRlcmFsID0gYi5saXRlcmFsKCdOdWxsTGl0ZXJhbCcsIG51bGwpO1xuICAgIGxldCBuZXh0U2libGluZyA9IGIucGFpcignbmV4dFNpYmxpbmcnLCBudWxsTGl0ZXJhbCk7XG4gICAgaGFzaC5wYWlycy5wdXNoKG5leHRTaWJsaW5nKTtcbiAgfVxuXG4gIHJldHVybiBoYXNoO1xufVxuXG5mdW5jdGlvbiBhcHBlbmREeW5hbWljQXR0cmlidXRlVmFsdWVQYXJ0KGF0dHJpYnV0ZTogQXR0cmlidXRlLCBwYXJ0OiBBU1QuTXVzdGFjaGVTdGF0ZW1lbnQpIHtcbiAgYXR0cmlidXRlLmlzRHluYW1pYyA9IHRydWU7XG4gIGF0dHJpYnV0ZS5wYXJ0cy5wdXNoKHBhcnQpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQge1xuICBQcm9ncmFtOiAgICAgICAgICAgICAgICAgIFsnYm9keSddLFxuXG4gIE11c3RhY2hlU3RhdGVtZW50OiAgICAgICAgWydwYXRoJywgJ3BhcmFtcycsICdoYXNoJ10sXG4gIEJsb2NrU3RhdGVtZW50OiAgICAgICAgICAgWydwYXRoJywgJ3BhcmFtcycsICdoYXNoJywgJ3Byb2dyYW0nLCAnaW52ZXJzZSddLFxuICBFbGVtZW50TW9kaWZpZXJTdGF0ZW1lbnQ6IFsncGF0aCcsICdwYXJhbXMnLCAnaGFzaCddLFxuICBQYXJ0aWFsU3RhdGVtZW50OiAgICAgICAgIFsnbmFtZScsICdwYXJhbXMnLCAnaGFzaCddLFxuICBDb21tZW50U3RhdGVtZW50OiAgICAgICAgIFtdLFxuICBNdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQ6IFtdLFxuICBFbGVtZW50Tm9kZTogICAgICAgICAgICAgIFsnYXR0cmlidXRlcycsICdtb2RpZmllcnMnLCAnY2hpbGRyZW4nLCAnY29tbWVudHMnXSxcbiAgQXR0ck5vZGU6ICAgICAgICAgICAgICAgICBbJ3ZhbHVlJ10sXG4gIFRleHROb2RlOiAgICAgICAgICAgICAgICAgW10sXG5cbiAgQ29uY2F0U3RhdGVtZW50OiAgICAgICAgICBbJ3BhcnRzJ10sXG4gIFN1YkV4cHJlc3Npb246ICAgICAgICAgICAgWydwYXRoJywgJ3BhcmFtcycsICdoYXNoJ10sXG4gIFBhdGhFeHByZXNzaW9uOiAgICAgICAgICAgW10sXG5cbiAgU3RyaW5nTGl0ZXJhbDogICAgICAgICAgICBbXSxcbiAgQm9vbGVhbkxpdGVyYWw6ICAgICAgICAgICBbXSxcbiAgTnVtYmVyTGl0ZXJhbDogICAgICAgICAgICBbXSxcbiAgTnVsbExpdGVyYWw6ICAgICAgICAgICAgICBbXSxcbiAgVW5kZWZpbmVkTGl0ZXJhbDogICAgICAgICBbXSxcblxuICBIYXNoOiAgICAgICAgICAgICAgICAgICAgIFsncGFpcnMnXSxcbiAgSGFzaFBhaXI6ICAgICAgICAgICAgICAgICBbJ3ZhbHVlJ11cbn07XG4iLCJpbXBvcnQgKiBhcyBBU1QgZnJvbSAnLi4vdHlwZXMvbm9kZXMnO1xuaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhdmVyc2FsRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yOiBUcmF2ZXJzYWxFcnJvckNvbnN0cnVjdG9yO1xuICBrZXk6IHN0cmluZztcbiAgbm9kZTogQVNULk5vZGU7XG4gIHBhcmVudDogT3B0aW9uPEFTVC5Ob2RlPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmF2ZXJzYWxFcnJvckNvbnN0cnVjdG9yIHtcbiAgbmV3IChtZXNzYWdlOiBzdHJpbmcsIG5vZGU6IEFTVC5Ob2RlLCBwYXJlbnQ6IE9wdGlvbjxBU1QuTm9kZT4sIGtleTogc3RyaW5nKTogVHJhdmVyc2FsRXJyb3I7XG4gIHJlYWRvbmx5IHByb3RvdHlwZTogVHJhdmVyc2FsRXJyb3I7XG59XG5cbmNvbnN0IFRyYXZlcnNhbEVycm9yOiBUcmF2ZXJzYWxFcnJvckNvbnN0cnVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgVHJhdmVyc2FsRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICBUcmF2ZXJzYWxFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUcmF2ZXJzYWxFcnJvcjtcblxuICBmdW5jdGlvbiBUcmF2ZXJzYWxFcnJvcih0aGlzOiBUcmF2ZXJzYWxFcnJvciwgbWVzc2FnZTogc3RyaW5nLCBub2RlOiBBU1QuTm9kZSwgcGFyZW50OiBPcHRpb248QVNULk5vZGU+LCBrZXk6IHN0cmluZykge1xuICAgIGxldCBlcnJvciA9IEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG5cbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5zdGFjayA9IGVycm9yLnN0YWNrO1xuICB9XG5cbiAgcmV0dXJuIFRyYXZlcnNhbEVycm9yIGFzIGFueTtcbn0oKSk7XG5cbmV4cG9ydCBkZWZhdWx0IFRyYXZlcnNhbEVycm9yO1xuXG5leHBvcnQgZnVuY3Rpb24gY2Fubm90UmVtb3ZlTm9kZShub2RlOiBBU1QuTm9kZSwgcGFyZW50OkFTVC5Ob2RlLCBrZXk6IHN0cmluZykge1xuICByZXR1cm4gbmV3IFRyYXZlcnNhbEVycm9yKFxuICAgIFwiQ2Fubm90IHJlbW92ZSBhIG5vZGUgdW5sZXNzIGl0IGlzIHBhcnQgb2YgYW4gYXJyYXlcIixcbiAgICBub2RlLCBwYXJlbnQsIGtleVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2Fubm90UmVwbGFjZU5vZGUobm9kZTogQVNULk5vZGUsIHBhcmVudDogQVNULk5vZGUsIGtleTogc3RyaW5nKSB7XG4gIHJldHVybiBuZXcgVHJhdmVyc2FsRXJyb3IoXG4gICAgXCJDYW5ub3QgcmVwbGFjZSBhIG5vZGUgd2l0aCBtdWx0aXBsZSBub2RlcyB1bmxlc3MgaXQgaXMgcGFydCBvZiBhbiBhcnJheVwiLFxuICAgIG5vZGUsIHBhcmVudCwga2V5XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYW5ub3RSZXBsYWNlT3JSZW1vdmVJbktleUhhbmRsZXJZZXQobm9kZTogQVNULk5vZGUsIGtleTogc3RyaW5nKSB7XG4gIHJldHVybiBuZXcgVHJhdmVyc2FsRXJyb3IoXG4gICAgXCJSZXBsYWNpbmcgYW5kIHJlbW92aW5nIGluIGtleSBoYW5kbGVycyBpcyBub3QgeWV0IHN1cHBvcnRlZC5cIixcbiAgICBub2RlLCBudWxsLCBrZXlcbiAgKTtcbn1cbiIsImltcG9ydCB2aXNpdG9yS2V5cyBmcm9tICcuLi90eXBlcy92aXNpdG9yLWtleXMnO1xuaW1wb3J0IHtcbiAgY2Fubm90UmVtb3ZlTm9kZSxcbiAgY2Fubm90UmVwbGFjZU5vZGUsXG4gIGNhbm5vdFJlcGxhY2VPclJlbW92ZUluS2V5SGFuZGxlcllldFxufSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgKiBhcyBub2RlcyBmcm9tICcuLi90eXBlcy9ub2Rlcyc7XG5pbXBvcnQgeyBPcHRpb24gfSBmcm9tIFwiQGdsaW1tZXIvaW50ZXJmYWNlc1wiO1xuXG5leHBvcnQgdHlwZSBOb2RlSGFuZGxlcjxUIGV4dGVuZHMgbm9kZXMuTm9kZT4gPSBOb2RlSGFuZGxlckZ1bmN0aW9uPFQ+IHwgRW50ZXJFeGl0Tm9kZUhhbmRsZXI8VD47XG5cbmV4cG9ydCB0eXBlIFNwZWNpZmljTm9kZVZpc2l0b3IgPSB7XG4gIFtQIGluIGtleW9mIG5vZGVzLk5vZGVzXT86IE5vZGVIYW5kbGVyPG5vZGVzLk5vZGVzW1BdPjtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm9kZVZpc2l0b3IgZXh0ZW5kcyBTcGVjaWZpY05vZGVWaXNpdG9yIHtcbiAgQWxsPzogTm9kZUhhbmRsZXI8bm9kZXMuTm9kZT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm9kZUhhbmRsZXJGdW5jdGlvbjxUIGV4dGVuZHMgbm9kZXMuTm9kZT4ge1xuICAodGhpczogbnVsbCwgbm9kZTogVCk6IGFueSB8IG51bGwgfCB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRW50ZXJFeGl0Tm9kZUhhbmRsZXI8VCBleHRlbmRzIG5vZGVzLk5vZGU+IHtcbiAgZW50ZXI/OiBOb2RlSGFuZGxlckZ1bmN0aW9uPFQ+O1xuICBleGl0PzogTm9kZUhhbmRsZXJGdW5jdGlvbjxUPjtcbiAga2V5cz86IGFueTtcbn1cblxuZnVuY3Rpb24gdmlzaXROb2RlKHZpc2l0b3I6IE5vZGVWaXNpdG9yLCBub2RlOiBub2Rlcy5Ob2RlKTogYW55IHtcbiAgbGV0IGhhbmRsZXI6IE9wdGlvbjxOb2RlSGFuZGxlcjxub2Rlcy5Ob2RlPj4gPSB2aXNpdG9yW25vZGUudHlwZV0gfHwgdmlzaXRvci5BbGwgfHwgbnVsbDtcbiAgbGV0IHJlc3VsdDtcblxuICBpZiAoaGFuZGxlciAmJiBoYW5kbGVyWydlbnRlciddKSB7XG4gICAgcmVzdWx0ID0gaGFuZGxlclsnZW50ZXInXS5jYWxsKG51bGwsIG5vZGUpO1xuICB9XG5cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIHJlc3VsdCAhPT0gbnVsbCkge1xuICAgIGlmIChKU09OLnN0cmluZ2lmeShub2RlKSA9PT0gSlNPTi5zdHJpbmdpZnkocmVzdWx0KSkge1xuICAgICAgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICByZXR1cm4gdmlzaXRBcnJheSh2aXNpdG9yLCByZXN1bHQpIHx8IHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpc2l0Tm9kZSh2aXNpdG9yLCByZXN1bHQpIHx8IHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICBsZXQga2V5cyA9IHZpc2l0b3JLZXlzW25vZGUudHlwZV07XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZpc2l0S2V5KHZpc2l0b3IsIGhhbmRsZXIgYXMgYW55LCBub2RlIGFzIGFueSwga2V5c1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKGhhbmRsZXIgJiYgaGFuZGxlclsnZXhpdCddKSB7XG4gICAgICByZXN1bHQgPSBoYW5kbGVyWydleGl0J10uY2FsbChudWxsLCBub2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB2aXNpdEtleSh2aXNpdG9yOiBOb2RlVmlzaXRvciwgaGFuZGxlcjogRW50ZXJFeGl0Tm9kZUhhbmRsZXI8bm9kZXMuTm9kZT4sIG5vZGU6IG5vZGVzLk5vZGUgJiBUcmF2ZXJzZWROb2RlLCBrZXk6IHN0cmluZykge1xuICBsZXQgdmFsdWUgPSBub2RlW2tleV07XG4gIGlmICghdmFsdWUpIHsgcmV0dXJuOyB9XG5cbiAgbGV0IGtleUhhbmRsZXIgPSBoYW5kbGVyICYmIChoYW5kbGVyLmtleXNba2V5XSB8fCBoYW5kbGVyLmtleXMuQWxsKTtcbiAgbGV0IHJlc3VsdDtcblxuICBpZiAoa2V5SGFuZGxlciAmJiBrZXlIYW5kbGVyLmVudGVyKSB7XG4gICAgcmVzdWx0ID0ga2V5SGFuZGxlci5lbnRlci5jYWxsKG51bGwsIG5vZGUsIGtleSk7XG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBjYW5ub3RSZXBsYWNlT3JSZW1vdmVJbktleUhhbmRsZXJZZXQobm9kZSwga2V5KTtcbiAgICB9XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2aXNpdEFycmF5KHZpc2l0b3IsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcmVzdWx0ID0gdmlzaXROb2RlKHZpc2l0b3IsIHZhbHVlKTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFzc2lnbktleShub2RlLCBrZXksIHJlc3VsdCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGtleUhhbmRsZXIgJiYga2V5SGFuZGxlci5leGl0KSB7XG4gICAgcmVzdWx0ID0ga2V5SGFuZGxlci5leGl0LmNhbGwobnVsbCwgbm9kZSwga2V5KTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IGNhbm5vdFJlcGxhY2VPclJlbW92ZUluS2V5SGFuZGxlcllldChub2RlLCBrZXkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2aXNpdEFycmF5KHZpc2l0b3I6IE5vZGVWaXNpdG9yLCBhcnJheTogbm9kZXMuTm9kZVtdKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgcmVzdWx0ID0gdmlzaXROb2RlKHZpc2l0b3IsIGFycmF5W2ldKTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGkgKz0gc3BsaWNlQXJyYXkoYXJyYXksIGksIHJlc3VsdCkgLSAxO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYXZlcnNlZE5vZGUge1xuICBba2V5OiBzdHJpbmddOiBub2Rlcy5Ob2RlO1xufVxuXG5mdW5jdGlvbiBhc3NpZ25LZXkobm9kZTogVHJhdmVyc2VkTm9kZSAmIG5vZGVzLk5vZGUsIGtleTogc3RyaW5nLCByZXN1bHQ6IG5vZGVzLk5vZGUpIHtcbiAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgIHRocm93IGNhbm5vdFJlbW92ZU5vZGUobm9kZVtrZXldLCBub2RlLCBrZXkpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAxKSB7XG4gICAgICBub2RlW2tleV0gPSByZXN1bHRbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IGNhbm5vdFJlbW92ZU5vZGUobm9kZVtrZXldLCBub2RlLCBrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgY2Fubm90UmVwbGFjZU5vZGUobm9kZVtrZXldLCBub2RlLCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlW2tleV0gPSByZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3BsaWNlQXJyYXk8VD4oYXJyYXk6IFRbXSwgaW5kZXg6IG51bWJlciwgcmVzdWx0OiBUW10pIHtcbiAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgIGFycmF5LnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgYXJyYXkuc3BsaWNlKGluZGV4LCAxLCAuLi5yZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIGFycmF5LnNwbGljZShpbmRleCwgMSwgcmVzdWx0KTtcbiAgICByZXR1cm4gMTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmF2ZXJzZShub2RlOiBub2Rlcy5Ob2RlLCB2aXNpdG9yOiBOb2RlVmlzaXRvcikge1xuICB2aXNpdE5vZGUobm9ybWFsaXplVmlzaXRvcih2aXNpdG9yKSwgbm9kZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVWaXNpdG9yKHZpc2l0b3I6IE5vZGVWaXNpdG9yKSB7XG4gIGxldCBub3JtYWxpemVkVmlzaXRvciA9IHt9O1xuXG4gIGZvciAobGV0IHR5cGUgaW4gdmlzaXRvcikge1xuICAgIGxldCBoYW5kbGVyID0gdmlzaXRvclt0eXBlXSB8fCB2aXNpdG9yLkFsbDtcbiAgICBsZXQgbm9ybWFsaXplZEtleXMgPSB7fTtcblxuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGxldCBrZXlzID0gaGFuZGxlci5rZXlzO1xuICAgICAgaWYgKGtleXMpIHtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGtleXMpIHtcbiAgICAgICAgICBsZXQga2V5SGFuZGxlciA9IGtleXNba2V5XTtcbiAgICAgICAgICBpZiAodHlwZW9mIGtleUhhbmRsZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkS2V5c1trZXldID0ge1xuICAgICAgICAgICAgICBlbnRlcjogKHR5cGVvZiBrZXlIYW5kbGVyLmVudGVyID09PSAnZnVuY3Rpb24nKSA/IGtleUhhbmRsZXIuZW50ZXIgOiBudWxsLFxuICAgICAgICAgICAgICBleGl0OiAodHlwZW9mIGtleUhhbmRsZXIuZXhpdCA9PT0gJ2Z1bmN0aW9uJykgPyBrZXlIYW5kbGVyLmV4aXQgOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGtleUhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRLZXlzW2tleV0gPSB7XG4gICAgICAgICAgICAgIGVudGVyOiBrZXlIYW5kbGVyLFxuICAgICAgICAgICAgICBleGl0OiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBub3JtYWxpemVkVmlzaXRvclt0eXBlXSA9IHtcbiAgICAgICAgZW50ZXI6ICh0eXBlb2YgaGFuZGxlci5lbnRlciA9PT0gJ2Z1bmN0aW9uJykgPyBoYW5kbGVyLmVudGVyIDogbnVsbCxcbiAgICAgICAgZXhpdDogKHR5cGVvZiBoYW5kbGVyLmV4aXQgPT09ICdmdW5jdGlvbicpID8gaGFuZGxlci5leGl0IDogbnVsbCxcbiAgICAgICAga2V5czogbm9ybWFsaXplZEtleXNcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbm9ybWFsaXplZFZpc2l0b3JbdHlwZV0gPSB7XG4gICAgICAgIGVudGVyOiBoYW5kbGVyLFxuICAgICAgICBleGl0OiBudWxsLFxuICAgICAgICBrZXlzOiBub3JtYWxpemVkS2V5c1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9ybWFsaXplZFZpc2l0b3I7XG59XG4iLCJpbXBvcnQgeyBPcHRpb24gfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCAqIGFzIEhCUyBmcm9tICcuLi90eXBlcy9ub2Rlcyc7XG5cbmZ1bmN0aW9uIHVucmVhY2hhYmxlKCk6IG5ldmVyIHtcbiAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZScpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZChhc3Q6IEhCUy5Ob2RlKTogc3RyaW5nIHtcbiAgaWYoIWFzdCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBjb25zdCBvdXRwdXQ6IHN0cmluZ1tdID0gW107XG5cbiAgc3dpdGNoKGFzdC50eXBlKSB7XG4gICAgY2FzZSAnUHJvZ3JhbSc6IHtcbiAgICAgIGNvbnN0IGNoYWluQmxvY2sgPSBhc3RbJ2NoYWluZWQnXSAmJiBhc3QuYm9keVswXTtcbiAgICAgIGlmKGNoYWluQmxvY2spIHtcbiAgICAgICAgY2hhaW5CbG9ja1snY2hhaW5lZCddID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJvZHkgPSBidWlsZEVhY2goYXN0LmJvZHkpLmpvaW4oJycpO1xuICAgICAgb3V0cHV0LnB1c2goYm9keSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICAgIGNhc2UgJ0VsZW1lbnROb2RlJzpcbiAgICAgIG91dHB1dC5wdXNoKCc8JywgYXN0LnRhZyk7XG4gICAgICBpZihhc3QuYXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goJyAnLCBidWlsZEVhY2goYXN0LmF0dHJpYnV0ZXMpLmpvaW4oJyAnKSk7XG4gICAgICB9XG4gICAgICBpZihhc3QubW9kaWZpZXJzLmxlbmd0aCkge1xuICAgICAgICBvdXRwdXQucHVzaCgnICcsIGJ1aWxkRWFjaChhc3QubW9kaWZpZXJzKS5qb2luKCcgJykpO1xuICAgICAgfVxuICAgICAgaWYoYXN0LmNvbW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBvdXRwdXQucHVzaCgnICcsIGJ1aWxkRWFjaChhc3QuY29tbWVudHMpLmpvaW4oJyAnKSk7XG4gICAgICB9XG4gICAgICBvdXRwdXQucHVzaCgnPicpO1xuICAgICAgb3V0cHV0LnB1c2guYXBwbHkob3V0cHV0LCBidWlsZEVhY2goYXN0LmNoaWxkcmVuKSk7XG4gICAgICBvdXRwdXQucHVzaCgnPC8nLCBhc3QudGFnLCAnPicpO1xuICAgIGJyZWFrO1xuICAgIGNhc2UgJ0F0dHJOb2RlJzpcbiAgICAgIG91dHB1dC5wdXNoKGFzdC5uYW1lLCAnPScpO1xuICAgICAgY29uc3QgdmFsdWUgPSBidWlsZChhc3QudmFsdWUpO1xuICAgICAgaWYoYXN0LnZhbHVlLnR5cGUgPT09ICdUZXh0Tm9kZScpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goJ1wiJywgdmFsdWUsICdcIicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIGJyZWFrO1xuICAgIGNhc2UgJ0NvbmNhdFN0YXRlbWVudCc6XG4gICAgICBvdXRwdXQucHVzaCgnXCInKTtcbiAgICAgIGFzdC5wYXJ0cy5mb3JFYWNoKChub2RlOiBhbnkpID0+IHtcbiAgICAgICAgaWYobm9kZS50eXBlID09PSAnU3RyaW5nTGl0ZXJhbCcpIHtcbiAgICAgICAgICBvdXRwdXQucHVzaChub2RlLm9yaWdpbmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRwdXQucHVzaChidWlsZChub2RlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb3V0cHV0LnB1c2goJ1wiJyk7XG4gICAgYnJlYWs7XG4gICAgY2FzZSAnVGV4dE5vZGUnOlxuICAgICAgb3V0cHV0LnB1c2goYXN0LmNoYXJzKTtcbiAgICBicmVhaztcbiAgICBjYXNlICdNdXN0YWNoZVN0YXRlbWVudCc6IHtcbiAgICAgIG91dHB1dC5wdXNoKGNvbXBhY3RKb2luKFsne3snLCBwYXRoUGFyYW1zKGFzdCksICd9fSddKSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICAgIGNhc2UgJ011c3RhY2hlQ29tbWVudFN0YXRlbWVudCc6IHtcbiAgICAgIG91dHB1dC5wdXNoKGNvbXBhY3RKb2luKFsne3shLS0nLCBhc3QudmFsdWUsICctLX19J10pKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gICAgY2FzZSAnRWxlbWVudE1vZGlmaWVyU3RhdGVtZW50Jzoge1xuICAgICAgb3V0cHV0LnB1c2goY29tcGFjdEpvaW4oWyd7eycsIHBhdGhQYXJhbXMoYXN0KSwgJ319J10pKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gICAgY2FzZSAnUGF0aEV4cHJlc3Npb24nOlxuICAgICAgb3V0cHV0LnB1c2goYXN0Lm9yaWdpbmFsKTtcbiAgICBicmVhaztcbiAgICBjYXNlICdTdWJFeHByZXNzaW9uJzoge1xuICAgICAgb3V0cHV0LnB1c2goJygnLCBwYXRoUGFyYW1zKGFzdCksICcpJyk7XG4gICAgfVxuICAgIGJyZWFrO1xuICAgIGNhc2UgJ0Jvb2xlYW5MaXRlcmFsJzpcbiAgICAgIG91dHB1dC5wdXNoKGFzdC52YWx1ZSA/ICd0cnVlJyA6ICdmYWxzZScpO1xuICAgIGJyZWFrO1xuICAgIGNhc2UgJ0Jsb2NrU3RhdGVtZW50Jzoge1xuICAgICAgY29uc3QgbGluZXM6IHN0cmluZ1tdID0gW107XG5cbiAgICAgIGlmKGFzdFsnY2hhaW5lZCddKXtcbiAgICAgICAgbGluZXMucHVzaChbJ3t7ZWxzZSAnLCBwYXRoUGFyYW1zKGFzdCksICd9fSddLmpvaW4oJycpKTtcbiAgICAgIH1lbHNle1xuICAgICAgICBsaW5lcy5wdXNoKG9wZW5CbG9jayhhc3QpKTtcbiAgICAgIH1cblxuICAgICAgbGluZXMucHVzaChidWlsZChhc3QucHJvZ3JhbSkpO1xuXG4gICAgICBpZihhc3QuaW52ZXJzZSkge1xuICAgICAgICBpZighYXN0LmludmVyc2VbJ2NoYWluZWQnXSl7XG4gICAgICAgICAgbGluZXMucHVzaCgne3tlbHNlfX0nKTtcbiAgICAgICAgfVxuICAgICAgICBsaW5lcy5wdXNoKGJ1aWxkKGFzdC5pbnZlcnNlKSk7XG4gICAgICB9XG5cbiAgICAgIGlmKCFhc3RbJ2NoYWluZWQnXSl7XG4gICAgICAgIGxpbmVzLnB1c2goY2xvc2VCbG9jayhhc3QpKTtcbiAgICAgIH1cblxuICAgICAgb3V0cHV0LnB1c2gobGluZXMuam9pbignJykpO1xuICAgIH1cbiAgICBicmVhaztcbiAgICBjYXNlICdQYXJ0aWFsU3RhdGVtZW50Jzoge1xuICAgICAgb3V0cHV0LnB1c2goY29tcGFjdEpvaW4oWyd7ez4nLCBwYXRoUGFyYW1zKGFzdCksICd9fSddKSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICAgIGNhc2UgJ0NvbW1lbnRTdGF0ZW1lbnQnOiB7XG4gICAgICBvdXRwdXQucHVzaChjb21wYWN0Sm9pbihbJzwhLS0nLCBhc3QudmFsdWUsICctLT4nXSkpO1xuICAgIH1cbiAgICBicmVhaztcbiAgICBjYXNlICdTdHJpbmdMaXRlcmFsJzoge1xuICAgICAgb3V0cHV0LnB1c2goYFwiJHthc3QudmFsdWV9XCJgKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gICAgY2FzZSAnTnVtYmVyTGl0ZXJhbCc6IHtcbiAgICAgIG91dHB1dC5wdXNoKFN0cmluZyhhc3QudmFsdWUpKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gICAgY2FzZSAnVW5kZWZpbmVkTGl0ZXJhbCc6IHtcbiAgICAgIG91dHB1dC5wdXNoKCd1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gICAgY2FzZSAnTnVsbExpdGVyYWwnOiB7XG4gICAgICBvdXRwdXQucHVzaCgnbnVsbCcpO1xuICAgIH1cbiAgICBicmVhaztcbiAgICBjYXNlICdIYXNoJzoge1xuICAgICAgb3V0cHV0LnB1c2goYXN0LnBhaXJzLm1hcChwYWlyID0+IHtcbiAgICAgICAgcmV0dXJuIGJ1aWxkKHBhaXIpO1xuICAgICAgfSkuam9pbignICcpKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gICAgY2FzZSAnSGFzaFBhaXInOiB7XG4gICAgICBvdXRwdXQucHVzaChgJHthc3Qua2V5fT0ke2J1aWxkKGFzdC52YWx1ZSl9YCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIGNvbXBhY3QoYXJyYXk6IE9wdGlvbjxzdHJpbmc+W10pOiBzdHJpbmdbXSB7XG4gIGNvbnN0IG5ld0FycmF5OiBhbnlbXSA9IFtdO1xuICBhcnJheS5mb3JFYWNoKGEgPT4ge1xuICAgIGlmKHR5cGVvZihhKSAhPT0gJ3VuZGVmaW5lZCcgJiYgYSAhPT0gbnVsbCAmJiBhICE9PSAnJykge1xuICAgICAgbmV3QXJyYXkucHVzaChhKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3QXJyYXk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRWFjaChhc3RzOiBIQlMuTm9kZVtdKTogc3RyaW5nW10ge1xuICByZXR1cm4gYXN0cy5tYXAoYnVpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXRoUGFyYW1zKGFzdDogSEJTLk5vZGUpOiBzdHJpbmcge1xuICBsZXQgcGF0aDogc3RyaW5nO1xuXG4gIHN3aXRjaCAoYXN0LnR5cGUpIHtcbiAgICBjYXNlICdNdXN0YWNoZVN0YXRlbWVudCc6XG4gICAgY2FzZSAnU3ViRXhwcmVzc2lvbic6XG4gICAgY2FzZSAnRWxlbWVudE1vZGlmaWVyU3RhdGVtZW50JzpcbiAgICBjYXNlICdCbG9ja1N0YXRlbWVudCc6XG4gICAgICBpZiAoSEJTLmlzTGl0ZXJhbChhc3QucGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhhc3QucGF0aC52YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHBhdGggPSBidWlsZChhc3QucGF0aCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdQYXJ0aWFsU3RhdGVtZW50JzpcbiAgICAgIHBhdGggPSBidWlsZChhc3QubmFtZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVucmVhY2hhYmxlKCk7XG4gIH1cblxuICByZXR1cm4gY29tcGFjdEpvaW4oW3BhdGgsIGJ1aWxkRWFjaChhc3QucGFyYW1zKS5qb2luKCcgJyksIGJ1aWxkKGFzdC5oYXNoKV0sICcgJyk7XG59XG5cbmZ1bmN0aW9uIGNvbXBhY3RKb2luKGFycmF5OiBPcHRpb248c3RyaW5nPltdLCBkZWxpbWl0ZXI/OiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gY29tcGFjdChhcnJheSkuam9pbihkZWxpbWl0ZXIgfHwgJycpO1xufVxuXG5mdW5jdGlvbiBibG9ja1BhcmFtcyhibG9jazogSEJTLkJsb2NrU3RhdGVtZW50KTogT3B0aW9uPHN0cmluZz4ge1xuICBjb25zdCBwYXJhbXMgPSBibG9jay5wcm9ncmFtLmJsb2NrUGFyYW1zO1xuICBpZihwYXJhbXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGAgYXMgfCR7cGFyYW1zLmpvaW4oJyAnKX18YDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBvcGVuQmxvY2soYmxvY2s6IEhCUy5CbG9ja1N0YXRlbWVudCk6IHN0cmluZyB7XG4gIHJldHVybiBbJ3t7IycsIHBhdGhQYXJhbXMoYmxvY2spLCBibG9ja1BhcmFtcyhibG9jayksICd9fSddLmpvaW4oJycpO1xufVxuXG5mdW5jdGlvbiBjbG9zZUJsb2NrKGJsb2NrOiBhbnkpOiBzdHJpbmcge1xuICByZXR1cm4gWyd7ey8nLCBidWlsZChibG9jay5wYXRoKSwgJ319J10uam9pbignJyk7XG59XG4iLCJpbXBvcnQgeyBPcHRpb24gfSBmcm9tIFwiQGdsaW1tZXIvaW50ZXJmYWNlc1wiO1xuaW1wb3J0ICogYXMgQVNUIGZyb20gJy4uL3R5cGVzL25vZGVzJztcblxuZXhwb3J0IHR5cGUgTm9kZUNhbGxiYWNrPE4gZXh0ZW5kcyBBU1QuTm9kZT4gPSAobm9kZTogTiwgd2Fsa2VyOiBXYWxrZXIpID0+IHZvaWQ7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdhbGtlciB7XG4gIHB1YmxpYyBzdGFjazogYW55W10gPSBbXTtcbiAgY29uc3RydWN0b3IocHVibGljIG9yZGVyPzogYW55KSB7fVxuXG4gIHZpc2l0PE4gZXh0ZW5kcyBBU1QuTm9kZT4obm9kZTogT3B0aW9uPE4+LCBjYWxsYmFjazogTm9kZUNhbGxiYWNrPE4+KSB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zdGFjay5wdXNoKG5vZGUpO1xuXG4gICAgaWYgKHRoaXMub3JkZXIgPT09ICdwb3N0Jykge1xuICAgICAgdGhpcy5jaGlsZHJlbihub2RlLCBjYWxsYmFjayk7XG4gICAgICBjYWxsYmFjayhub2RlLCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sobm9kZSwgdGhpcyk7XG4gICAgICB0aGlzLmNoaWxkcmVuKG5vZGUsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICB9XG5cbiAgY2hpbGRyZW4obm9kZTogYW55LCBjYWxsYmFjazogYW55KSB7XG4gICAgbGV0IHZpc2l0b3IgPSB2aXNpdG9yc1tub2RlLnR5cGVdO1xuICAgIGlmICh2aXNpdG9yKSB7XG4gICAgICB2aXNpdG9yKHRoaXMsIG5vZGUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbn1cblxubGV0IHZpc2l0b3JzID0ge1xuICBQcm9ncmFtKHdhbGtlcjogV2Fsa2VyLCBub2RlOiBBU1QuUHJvZ3JhbSwgY2FsbGJhY2s6IE5vZGVDYWxsYmFjazxBU1QuTm9kZT4pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgd2Fsa2VyLnZpc2l0KG5vZGUuYm9keVtpXSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfSxcblxuICBFbGVtZW50Tm9kZSh3YWxrZXI6IFdhbGtlciwgbm9kZTogQVNULkVsZW1lbnROb2RlLCBjYWxsYmFjazogTm9kZUNhbGxiYWNrPEFTVC5Ob2RlPikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgd2Fsa2VyLnZpc2l0KG5vZGUuY2hpbGRyZW5baV0sIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0sXG5cbiAgQmxvY2tTdGF0ZW1lbnQod2Fsa2VyOiBXYWxrZXIsIG5vZGU6IEFTVC5CbG9ja1N0YXRlbWVudCwgY2FsbGJhY2s6IE5vZGVDYWxsYmFjazxBU1QuUHJvZ3JhbT4pIHtcbiAgICB3YWxrZXIudmlzaXQobm9kZS5wcm9ncmFtLCBjYWxsYmFjayk7XG4gICAgd2Fsa2VyLnZpc2l0KG5vZGUuaW52ZXJzZSB8fCBudWxsLCBjYWxsYmFjayk7XG4gIH1cbn07XG4iLCJpbXBvcnQgYiwgeyBTWU5USEVUSUMgfSBmcm9tIFwiLi4vYnVpbGRlcnNcIjtcbmltcG9ydCB7IGFwcGVuZENoaWxkLCBwYXJzZUVsZW1lbnRCbG9ja1BhcmFtcyB9IGZyb20gXCIuLi91dGlsc1wiO1xuaW1wb3J0IHsgSGFuZGxlYmFyc05vZGVWaXNpdG9ycyB9IGZyb20gJy4vaGFuZGxlYmFycy1ub2RlLXZpc2l0b3JzJztcbmltcG9ydCAqIGFzIEFTVCBmcm9tIFwiLi4vdHlwZXMvbm9kZXNcIjtcbmltcG9ydCBTeW50YXhFcnJvciBmcm9tICcuLi9lcnJvcnMvc3ludGF4LWVycm9yJztcbmltcG9ydCB7IFRhZyB9IGZyb20gXCIuLi9wYXJzZXJcIjtcbmltcG9ydCBidWlsZGVycyBmcm9tIFwiLi4vYnVpbGRlcnNcIjtcbmltcG9ydCB0cmF2ZXJzZSwgeyBOb2RlVmlzaXRvciB9IGZyb20gXCIuLi90cmF2ZXJzYWwvdHJhdmVyc2VcIjtcbmltcG9ydCBwcmludCBmcm9tIFwiLi4vZ2VuZXJhdGlvbi9wcmludFwiO1xuaW1wb3J0IFdhbGtlciBmcm9tIFwiLi4vdHJhdmVyc2FsL3dhbGtlclwiO1xuaW1wb3J0ICogYXMgaGFuZGxlYmFycyBmcm9tIFwiaGFuZGxlYmFyc1wiO1xuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBSZWNhc3QgfSBmcm9tIFwiQGdsaW1tZXIvaW50ZXJmYWNlc1wiO1xuXG5jb25zdCB2b2lkTWFwOiB7XG4gIFt0YWdOYW1lOiBzdHJpbmddOiBib29sZWFuXG59ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxubGV0IHZvaWRUYWdOYW1lcyA9IFwiYXJlYSBiYXNlIGJyIGNvbCBjb21tYW5kIGVtYmVkIGhyIGltZyBpbnB1dCBrZXlnZW4gbGluayBtZXRhIHBhcmFtIHNvdXJjZSB0cmFjayB3YnJcIjtcbnZvaWRUYWdOYW1lcy5zcGxpdChcIiBcIikuZm9yRWFjaCh0YWdOYW1lID0+IHtcbiAgdm9pZE1hcFt0YWdOYW1lXSA9IHRydWU7XG59KTtcblxuZXhwb3J0IGNsYXNzIFRva2VuaXplckV2ZW50SGFuZGxlcnMgZXh0ZW5kcyBIYW5kbGViYXJzTm9kZVZpc2l0b3JzIHtcbiAgcHJpdmF0ZSB0YWdPcGVuTGluZSA9IDA7XG4gIHByaXZhdGUgdGFnT3BlbkNvbHVtbiA9IDA7XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5jdXJyZW50Tm9kZSA9IG51bGw7XG4gIH1cblxuICAvLyBDb21tZW50XG5cbiAgYmVnaW5Db21tZW50KCkge1xuICAgIHRoaXMuY3VycmVudE5vZGUgPSBiLmNvbW1lbnQoXCJcIik7XG4gICAgdGhpcy5jdXJyZW50Tm9kZS5sb2MgPSB7XG4gICAgICBzb3VyY2U6IG51bGwsXG4gICAgICBzdGFydDogYi5wb3ModGhpcy50YWdPcGVuTGluZSwgdGhpcy50YWdPcGVuQ29sdW1uKSxcbiAgICAgIGVuZDogbnVsbCBhcyBSZWNhc3Q8bnVsbCwgQVNULlBvc2l0aW9uPlxuICAgIH07XG4gIH1cblxuICBhcHBlbmRUb0NvbW1lbnREYXRhKGNoYXI6IHN0cmluZykge1xuICAgIHRoaXMuY3VycmVudENvbW1lbnQudmFsdWUgKz0gY2hhcjtcbiAgfVxuXG4gIGZpbmlzaENvbW1lbnQoKSB7XG4gICAgdGhpcy5jdXJyZW50Q29tbWVudC5sb2MuZW5kID0gYi5wb3ModGhpcy50b2tlbml6ZXIubGluZSwgdGhpcy50b2tlbml6ZXIuY29sdW1uKTtcblxuICAgIGFwcGVuZENoaWxkKHRoaXMuY3VycmVudEVsZW1lbnQoKSwgdGhpcy5jdXJyZW50Q29tbWVudCk7XG4gIH1cblxuICAvLyBEYXRhXG5cbiAgYmVnaW5EYXRhKCkge1xuICAgIHRoaXMuY3VycmVudE5vZGUgPSBiLnRleHQoKTtcbiAgICB0aGlzLmN1cnJlbnROb2RlLmxvYyA9IHtcbiAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgIHN0YXJ0OiBiLnBvcyh0aGlzLnRva2VuaXplci5saW5lLCB0aGlzLnRva2VuaXplci5jb2x1bW4pLFxuICAgICAgZW5kOiBudWxsIGFzIFJlY2FzdDxudWxsLCBBU1QuUG9zaXRpb24+XG4gICAgfTtcbiAgfVxuXG4gIGFwcGVuZFRvRGF0YShjaGFyOiBzdHJpbmcpIHtcbiAgICB0aGlzLmN1cnJlbnREYXRhLmNoYXJzICs9IGNoYXI7XG4gIH1cblxuICBmaW5pc2hEYXRhKCkge1xuICAgIHRoaXMuY3VycmVudERhdGEubG9jLmVuZCA9IGIucG9zKHRoaXMudG9rZW5pemVyLmxpbmUsIHRoaXMudG9rZW5pemVyLmNvbHVtbik7XG5cbiAgICBhcHBlbmRDaGlsZCh0aGlzLmN1cnJlbnRFbGVtZW50KCksIHRoaXMuY3VycmVudERhdGEpO1xuICB9XG5cbiAgLy8gVGFncyAtIGJhc2ljXG5cbiAgdGFnT3BlbigpIHtcbiAgICB0aGlzLnRhZ09wZW5MaW5lID0gdGhpcy50b2tlbml6ZXIubGluZTtcbiAgICB0aGlzLnRhZ09wZW5Db2x1bW4gPSB0aGlzLnRva2VuaXplci5jb2x1bW47XG4gIH1cblxuICBiZWdpblN0YXJ0VGFnKCkge1xuICAgIHRoaXMuY3VycmVudE5vZGUgPSB7XG4gICAgICB0eXBlOiAnU3RhcnRUYWcnLFxuICAgICAgbmFtZTogXCJcIixcbiAgICAgIGF0dHJpYnV0ZXM6IFtdLFxuICAgICAgbW9kaWZpZXJzOiBbXSxcbiAgICAgIGNvbW1lbnRzOiBbXSxcbiAgICAgIHNlbGZDbG9zaW5nOiBmYWxzZSxcbiAgICAgIGxvYzogU1lOVEhFVElDXG4gICAgfTtcbiAgfVxuXG4gIGJlZ2luRW5kVGFnKCkge1xuICAgIHRoaXMuY3VycmVudE5vZGUgPSB7XG4gICAgICB0eXBlOiAnRW5kVGFnJyxcbiAgICAgIG5hbWU6IFwiXCIsXG4gICAgICBhdHRyaWJ1dGVzOiBbXSxcbiAgICAgIG1vZGlmaWVyczogW10sXG4gICAgICBjb21tZW50czogW10sXG4gICAgICBzZWxmQ2xvc2luZzogZmFsc2UsXG4gICAgICBsb2M6IFNZTlRIRVRJQ1xuICAgIH07XG4gIH1cblxuICBmaW5pc2hUYWcoKSB7XG4gICAgbGV0IHsgbGluZSwgY29sdW1uIH0gPSB0aGlzLnRva2VuaXplcjtcblxuICAgIGxldCB0YWcgPSB0aGlzLmN1cnJlbnRUYWc7XG4gICAgdGFnLmxvYyA9IGIubG9jKHRoaXMudGFnT3BlbkxpbmUsIHRoaXMudGFnT3BlbkNvbHVtbiwgbGluZSwgY29sdW1uKTtcblxuICAgIGlmICh0YWcudHlwZSA9PT0gJ1N0YXJ0VGFnJykge1xuICAgICAgdGhpcy5maW5pc2hTdGFydFRhZygpO1xuXG4gICAgICBpZiAodm9pZE1hcFt0YWcubmFtZV0gfHwgdGFnLnNlbGZDbG9zaW5nKSB7XG4gICAgICAgIHRoaXMuZmluaXNoRW5kVGFnKHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGFnLnR5cGUgPT09ICdFbmRUYWcnKSB7XG4gICAgICB0aGlzLmZpbmlzaEVuZFRhZyhmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgZmluaXNoU3RhcnRUYWcoKSB7XG4gICAgbGV0IHsgbmFtZSwgYXR0cmlidXRlcywgbW9kaWZpZXJzLCBjb21tZW50cyB9ID0gdGhpcy5jdXJyZW50U3RhcnRUYWc7XG5cbiAgICBsZXQgbG9jID0gYi5sb2ModGhpcy50YWdPcGVuTGluZSwgdGhpcy50YWdPcGVuQ29sdW1uKTtcbiAgICBsZXQgZWxlbWVudCA9IGIuZWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzLCBtb2RpZmllcnMsIFtdLCBjb21tZW50cywgbG9jKTtcbiAgICB0aGlzLmVsZW1lbnRTdGFjay5wdXNoKGVsZW1lbnQpO1xuICB9XG5cbiAgZmluaXNoRW5kVGFnKGlzVm9pZDogYm9vbGVhbikge1xuICAgIGxldCB0YWcgPSB0aGlzLmN1cnJlbnRUYWc7XG5cbiAgICBsZXQgZWxlbWVudCA9IHRoaXMuZWxlbWVudFN0YWNrLnBvcCgpIGFzIEFTVC5FbGVtZW50Tm9kZTtcbiAgICBsZXQgcGFyZW50ID0gdGhpcy5jdXJyZW50RWxlbWVudCgpO1xuXG4gICAgdmFsaWRhdGVFbmRUYWcodGFnLCBlbGVtZW50LCBpc1ZvaWQpO1xuXG4gICAgZWxlbWVudC5sb2MuZW5kLmxpbmUgPSB0aGlzLnRva2VuaXplci5saW5lO1xuICAgIGVsZW1lbnQubG9jLmVuZC5jb2x1bW4gPSB0aGlzLnRva2VuaXplci5jb2x1bW47XG5cbiAgICBwYXJzZUVsZW1lbnRCbG9ja1BhcmFtcyhlbGVtZW50KTtcbiAgICBhcHBlbmRDaGlsZChwYXJlbnQsIGVsZW1lbnQpO1xuICB9XG5cbiAgbWFya1RhZ0FzU2VsZkNsb3NpbmcoKSB7XG4gICAgdGhpcy5jdXJyZW50VGFnLnNlbGZDbG9zaW5nID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIFRhZ3MgLSBuYW1lXG5cbiAgYXBwZW5kVG9UYWdOYW1lKGNoYXI6IHN0cmluZykge1xuICAgIHRoaXMuY3VycmVudFRhZy5uYW1lICs9IGNoYXI7XG4gIH1cblxuICAvLyBUYWdzIC0gYXR0cmlidXRlc1xuXG4gIGJlZ2luQXR0cmlidXRlKCkge1xuICAgIGxldCB0YWcgPSB0aGlzLmN1cnJlbnRUYWc7XG4gICAgaWYgKHRhZy50eXBlID09PSAnRW5kVGFnJykge1xuICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgYEludmFsaWQgZW5kIHRhZzogY2xvc2luZyB0YWcgbXVzdCBub3QgaGF2ZSBhdHRyaWJ1dGVzLCBgICtcbiAgICAgICAgYGluIFxcYCR7dGFnLm5hbWV9XFxgIChvbiBsaW5lICR7dGhpcy50b2tlbml6ZXIubGluZX0pLmAsXG4gICAgICAgIHRhZy5sb2NcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50QXR0cmlidXRlID0ge1xuICAgICAgbmFtZTogXCJcIixcbiAgICAgIHBhcnRzOiBbXSxcbiAgICAgIGlzUXVvdGVkOiBmYWxzZSxcbiAgICAgIGlzRHluYW1pYzogZmFsc2UsXG4gICAgICBzdGFydDogYi5wb3ModGhpcy50b2tlbml6ZXIubGluZSwgdGhpcy50b2tlbml6ZXIuY29sdW1uKSxcbiAgICAgIHZhbHVlU3RhcnRMaW5lOiAwLFxuICAgICAgdmFsdWVTdGFydENvbHVtbjogMFxuICAgIH07XG4gIH1cblxuICBhcHBlbmRUb0F0dHJpYnV0ZU5hbWUoY2hhcjogc3RyaW5nKSB7XG4gICAgdGhpcy5jdXJyZW50QXR0ci5uYW1lICs9IGNoYXI7XG4gIH1cblxuICBiZWdpbkF0dHJpYnV0ZVZhbHVlKGlzUXVvdGVkOiBib29sZWFuKSB7XG4gICAgdGhpcy5jdXJyZW50QXR0ci5pc1F1b3RlZCA9IGlzUXVvdGVkO1xuICAgIHRoaXMuY3VycmVudEF0dHIudmFsdWVTdGFydExpbmUgPSB0aGlzLnRva2VuaXplci5saW5lO1xuICAgIHRoaXMuY3VycmVudEF0dHIudmFsdWVTdGFydENvbHVtbiA9IHRoaXMudG9rZW5pemVyLmNvbHVtbjtcbiAgfVxuXG4gIGFwcGVuZFRvQXR0cmlidXRlVmFsdWUoY2hhcjogc3RyaW5nKSB7XG4gICAgbGV0IHBhcnRzID0gdGhpcy5jdXJyZW50QXR0ci5wYXJ0cztcbiAgICBsZXQgbGFzdFBhcnQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcblxuICAgIGlmIChsYXN0UGFydCAmJiBsYXN0UGFydC50eXBlID09PSAnVGV4dE5vZGUnKSB7XG4gICAgICBsYXN0UGFydC5jaGFycyArPSBjaGFyO1xuXG4gICAgICAvLyB1cGRhdGUgZW5kIGxvY2F0aW9uIGZvciBlYWNoIGFkZGVkIGNoYXJcbiAgICAgIGxhc3RQYXJ0LmxvYy5lbmQubGluZSA9IHRoaXMudG9rZW5pemVyLmxpbmU7XG4gICAgICBsYXN0UGFydC5sb2MuZW5kLmNvbHVtbiA9IHRoaXMudG9rZW5pemVyLmNvbHVtbjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW5pdGlhbGx5IGFzc3VtZSB0aGUgdGV4dCBub2RlIGlzIGEgc2luZ2xlIGNoYXJcbiAgICAgIGxldCBsb2MgPSBiLmxvYyhcbiAgICAgICAgdGhpcy50b2tlbml6ZXIubGluZSwgdGhpcy50b2tlbml6ZXIuY29sdW1uLFxuICAgICAgICB0aGlzLnRva2VuaXplci5saW5lLCB0aGlzLnRva2VuaXplci5jb2x1bW5cbiAgICAgICk7XG5cbiAgICAgIC8vIGNvcnJlY3QgZm9yIGBcXG5gIGFzIGZpcnN0IGNoYXJcbiAgICAgIGlmIChjaGFyID09PSAnXFxuJykge1xuICAgICAgICBsb2Muc3RhcnQubGluZSAtPSAxO1xuICAgICAgICBsb2Muc3RhcnQuY29sdW1uID0gbGFzdFBhcnQgPyBsYXN0UGFydC5sb2MuZW5kLmNvbHVtbiA6IHRoaXMuY3VycmVudEF0dHIudmFsdWVTdGFydENvbHVtbjtcbiAgICAgIH1cblxuICAgICAgbGV0IHRleHQgPSBiLnRleHQoY2hhciwgbG9jKTtcbiAgICAgIHBhcnRzLnB1c2godGV4dCk7XG4gICAgfVxuICB9XG5cbiAgZmluaXNoQXR0cmlidXRlVmFsdWUoKSB7XG4gICAgbGV0IHsgbmFtZSwgcGFydHMsIGlzUXVvdGVkLCBpc0R5bmFtaWMsIHZhbHVlU3RhcnRMaW5lLCB2YWx1ZVN0YXJ0Q29sdW1uIH0gPSB0aGlzLmN1cnJlbnRBdHRyO1xuICAgIGxldCB2YWx1ZSA9IGFzc2VtYmxlQXR0cmlidXRlVmFsdWUocGFydHMsIGlzUXVvdGVkLCBpc0R5bmFtaWMsIHRoaXMudG9rZW5pemVyLmxpbmUpO1xuICAgIHZhbHVlLmxvYyA9IGIubG9jKFxuICAgICAgdmFsdWVTdGFydExpbmUsIHZhbHVlU3RhcnRDb2x1bW4sXG4gICAgICB0aGlzLnRva2VuaXplci5saW5lLCB0aGlzLnRva2VuaXplci5jb2x1bW5cbiAgICApO1xuXG4gICAgbGV0IGxvYyA9IGIubG9jKFxuICAgICAgdGhpcy5jdXJyZW50QXR0ci5zdGFydC5saW5lLCB0aGlzLmN1cnJlbnRBdHRyLnN0YXJ0LmNvbHVtbixcbiAgICAgIHRoaXMudG9rZW5pemVyLmxpbmUsIHRoaXMudG9rZW5pemVyLmNvbHVtblxuICAgICk7XG5cbiAgICBsZXQgYXR0cmlidXRlID0gYi5hdHRyKG5hbWUsIHZhbHVlLCBsb2MpO1xuXG4gICAgdGhpcy5jdXJyZW50U3RhcnRUYWcuYXR0cmlidXRlcy5wdXNoKGF0dHJpYnV0ZSk7XG4gIH1cblxuICByZXBvcnRTeW50YXhFcnJvcihtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFN5bnRheCBlcnJvciBhdCBsaW5lICR7dGhpcy50b2tlbml6ZXIubGluZX0gY29sICR7dGhpcy50b2tlbml6ZXIuY29sdW1ufTogJHttZXNzYWdlfWAsIGIubG9jKHRoaXMudG9rZW5pemVyLmxpbmUsIHRoaXMudG9rZW5pemVyLmNvbHVtbikpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBhc3NlbWJsZUF0dHJpYnV0ZVZhbHVlKHBhcnRzOiAoQVNULk11c3RhY2hlU3RhdGVtZW50IHwgQVNULlRleHROb2RlKVtdLCBpc1F1b3RlZDogYm9vbGVhbiwgaXNEeW5hbWljOiBib29sZWFuLCBsaW5lOiBudW1iZXIpIHtcbiAgaWYgKGlzRHluYW1pYykge1xuICAgIGlmIChpc1F1b3RlZCkge1xuICAgICAgcmV0dXJuIGFzc2VtYmxlQ29uY2F0ZW5hdGVkVmFsdWUocGFydHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGFydHMubGVuZ3RoID09PSAxIHx8IChwYXJ0cy5sZW5ndGggPT09IDIgJiYgcGFydHNbMV0udHlwZSA9PT0gJ1RleHROb2RlJyAmJiAocGFydHNbMV0gYXMgQVNULlRleHROb2RlKS5jaGFycyA9PT0gJy8nKSkge1xuICAgICAgICByZXR1cm4gcGFydHNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgICAgYEFuIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgbXVzdGFjaGUsIGAgK1xuICAgICAgICAgIGBwcmVjZWVkZWQgYnkgd2hpdGVzcGFjZSBvciBhICc9JyBjaGFyYWN0ZXIsIGFuZCBgICtcbiAgICAgICAgICBgZm9sbG93ZWQgYnkgd2hpdGVzcGFjZSwgYSAnPicgY2hhcmFjdGVyLCBvciAnLz4nIChvbiBsaW5lICR7bGluZX0pYCxcbiAgICAgICAgICBiLmxvYyhsaW5lLCAwKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFydHMubGVuZ3RoID4gMCA/IHBhcnRzWzBdIDogYi50ZXh0KFwiXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VtYmxlQ29uY2F0ZW5hdGVkVmFsdWUocGFydHM6IChBU1QuTXVzdGFjaGVTdGF0ZW1lbnQgfCBBU1QuVGV4dE5vZGUpW10pIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBwYXJ0OiBBU1QuQmFzZU5vZGUgPSBwYXJ0c1tpXTtcblxuICAgIGlmIChwYXJ0LnR5cGUgIT09ICdNdXN0YWNoZVN0YXRlbWVudCcgJiYgcGFydC50eXBlICE9PSAnVGV4dE5vZGUnKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJVbnN1cHBvcnRlZCBub2RlIGluIHF1b3RlZCBhdHRyaWJ1dGUgdmFsdWU6IFwiICsgcGFydFsndHlwZSddLCBwYXJ0LmxvYyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGIuY29uY2F0KHBhcnRzKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVFbmRUYWcodGFnOiBUYWc8J1N0YXJ0VGFnJyB8ICdFbmRUYWcnPiwgZWxlbWVudDogQVNULkVsZW1lbnROb2RlLCBzZWxmQ2xvc2luZzogYm9vbGVhbikge1xuICBsZXQgZXJyb3I7XG5cbiAgaWYgKHZvaWRNYXBbdGFnLm5hbWVdICYmICFzZWxmQ2xvc2luZykge1xuICAgIC8vIEVuZ1RhZyBpcyBhbHNvIGNhbGxlZCBieSBTdGFydFRhZyBmb3Igdm9pZCBhbmQgc2VsZi1jbG9zaW5nIHRhZ3MgKGkuZS5cbiAgICAvLyA8aW5wdXQ+IG9yIDxiciAvPiwgc28gd2UgbmVlZCB0byBjaGVjayBmb3IgdGhhdCBoZXJlLiBPdGhlcndpc2UsIHdlIHdvdWxkXG4gICAgLy8gdGhyb3cgYW4gZXJyb3IgZm9yIHRob3NlIGNhc2VzLlxuICAgIGVycm9yID0gXCJJbnZhbGlkIGVuZCB0YWcgXCIgKyBmb3JtYXRFbmRUYWdJbmZvKHRhZykgKyBcIiAodm9pZCBlbGVtZW50cyBjYW5ub3QgaGF2ZSBlbmQgdGFncykuXCI7XG4gIH0gZWxzZSBpZiAoZWxlbWVudC50YWcgPT09IHVuZGVmaW5lZCkge1xuICAgIGVycm9yID0gXCJDbG9zaW5nIHRhZyBcIiArIGZvcm1hdEVuZFRhZ0luZm8odGFnKSArIFwiIHdpdGhvdXQgYW4gb3BlbiB0YWcuXCI7XG4gIH0gZWxzZSBpZiAoZWxlbWVudC50YWcgIT09IHRhZy5uYW1lKSB7XG4gICAgZXJyb3IgPSBcIkNsb3NpbmcgdGFnIFwiICsgZm9ybWF0RW5kVGFnSW5mbyh0YWcpICsgXCIgZGlkIG5vdCBtYXRjaCBsYXN0IG9wZW4gdGFnIGBcIiArIGVsZW1lbnQudGFnICsgXCJgIChvbiBsaW5lIFwiICtcbiAgICAgICAgICAgIGVsZW1lbnQubG9jLnN0YXJ0LmxpbmUgKyBcIikuXCI7XG4gIH1cblxuICBpZiAoZXJyb3IpIHsgdGhyb3cgbmV3IFN5bnRheEVycm9yKGVycm9yLCBlbGVtZW50LmxvYyk7IH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0RW5kVGFnSW5mbyh0YWc6IFRhZzwnU3RhcnRUYWcnIHwgJ0VuZFRhZyc+KSB7XG4gIHJldHVybiBcImBcIiArIHRhZy5uYW1lICsgXCJgIChvbiBsaW5lIFwiICsgdGFnLmxvYy5lbmQubGluZSArIFwiKVwiO1xufVxuXG4vKipcbiAgQVNUUGx1Z2lucyBjYW4gbWFrZSBjaGFuZ2VzIHRvIHRoZSBHbGltbWVyIHRlbXBsYXRlIEFTVCBiZWZvcmVcbiAgY29tcGlsYXRpb24gYmVnaW5zLlxuKi9cbmV4cG9ydCBpbnRlcmZhY2UgQVNUUGx1Z2luQnVpbGRlciB7XG4gIChlbnY6IEFTVFBsdWdpbkVudmlyb25tZW50KTogQVNUUGx1Z2luO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFTVFBsdWdpbiB7XG4gIG5hbWU6IHN0cmluZztcbiAgdmlzaXRvcjogTm9kZVZpc2l0b3I7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQVNUUGx1Z2luRW52aXJvbm1lbnQge1xuICBtZXRhPzogYW55O1xuICBzeW50YXg6IFN5bnRheDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcmVwcm9jZXNzT3B0aW9ucyB7XG4gIHBsdWdpbnM/OiB7XG4gICAgYXN0PzogQVNUUGx1Z2luQnVpbGRlcltdO1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN5bnRheCB7XG4gIHBhcnNlOiB0eXBlb2YgcHJlcHJvY2VzcztcbiAgYnVpbGRlcnM6IHR5cGVvZiBidWlsZGVycztcbiAgcHJpbnQ6IHR5cGVvZiBwcmludDtcbiAgdHJhdmVyc2U6IHR5cGVvZiB0cmF2ZXJzZTtcbiAgV2Fsa2VyOiB0eXBlb2YgV2Fsa2VyO1xufVxuXG5jb25zdCBzeW50YXg6IFN5bnRheCA9IHtcbiAgcGFyc2U6IHByZXByb2Nlc3MsXG4gIGJ1aWxkZXJzLFxuICBwcmludCxcbiAgdHJhdmVyc2UsXG4gIFdhbGtlclxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHByZXByb2Nlc3MoaHRtbDogc3RyaW5nLCBvcHRpb25zPzogUHJlcHJvY2Vzc09wdGlvbnMpOiBBU1QuUHJvZ3JhbSB7XG4gIGxldCBhc3QgPSAodHlwZW9mIGh0bWwgPT09ICdvYmplY3QnKSA/IGh0bWwgOiBoYW5kbGViYXJzLnBhcnNlKGh0bWwpO1xuICBsZXQgcHJvZ3JhbSA9IG5ldyBUb2tlbml6ZXJFdmVudEhhbmRsZXJzKGh0bWwsIG9wdGlvbnMpLmFjY2VwdE5vZGUoYXN0KTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnBsdWdpbnMgJiYgb3B0aW9ucy5wbHVnaW5zLmFzdCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gb3B0aW9ucy5wbHVnaW5zLmFzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxldCB0cmFuc2Zvcm0gPSBvcHRpb25zLnBsdWdpbnMuYXN0W2ldO1xuICAgICAgbGV0IGVudiA9IGFzc2lnbih7fSwgb3B0aW9ucywgeyBzeW50YXggfSwgeyBwbHVnaW5zOiB1bmRlZmluZWQgfSk7XG5cbiAgICAgIGxldCBwbHVnaW5SZXN1bHQgPSB0cmFuc2Zvcm0oZW52KTtcblxuICAgICAgdHJhdmVyc2UocHJvZ3JhbSwgcGx1Z2luUmVzdWx0LnZpc2l0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9ncmFtO1xufVxuIiwiLy8gdXNlZCBieSBlbWJlci1jb21waWxlclxuZXhwb3J0IHtcbiAgcHJlcHJvY2VzcyxcbiAgUHJlcHJvY2Vzc09wdGlvbnMsXG4gIEFTVFBsdWdpbixcbiAgQVNUUGx1Z2luQnVpbGRlcixcbiAgQVNUUGx1Z2luRW52aXJvbm1lbnQsXG4gIFN5bnRheFxufSBmcm9tICcuL2xpYi9wYXJzZXIvdG9rZW5pemVyLWV2ZW50LWhhbmRsZXJzJztcblxuLy8gbmVlZGVkIGZvciB0ZXN0cyBvbmx5XG5leHBvcnQgeyBkZWZhdWx0IGFzIGJ1aWxkZXJzIH0gZnJvbSAnLi9saWIvYnVpbGRlcnMnO1xuZXhwb3J0IHtcbiAgZGVmYXVsdCBhcyBUcmF2ZXJzYWxFcnJvcixcbiAgY2Fubm90UmVtb3ZlTm9kZSxcbiAgY2Fubm90UmVwbGFjZU5vZGUsXG4gIGNhbm5vdFJlcGxhY2VPclJlbW92ZUluS2V5SGFuZGxlcllldFxufSBmcm9tICcuL2xpYi90cmF2ZXJzYWwvZXJyb3JzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdHJhdmVyc2UsIE5vZGVIYW5kbGVyLCBOb2RlVmlzaXRvciwgTm9kZUhhbmRsZXJGdW5jdGlvbiwgRW50ZXJFeGl0Tm9kZUhhbmRsZXIgfSBmcm9tICcuL2xpYi90cmF2ZXJzYWwvdHJhdmVyc2UnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBXYWxrZXIgfSBmcm9tICcuL2xpYi90cmF2ZXJzYWwvd2Fsa2VyJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcHJpbnQgfSBmcm9tICcuL2xpYi9nZW5lcmF0aW9uL3ByaW50JztcblxuLy8gZXJyb3JzXG5leHBvcnQgeyBkZWZhdWx0IGFzIFN5bnRheEVycm9yIH0gZnJvbSAnLi9saWIvZXJyb3JzL3N5bnRheC1lcnJvcic7XG5cbi8vIEFTVFxuaW1wb3J0ICogYXMgQVNUIGZyb20gJy4vbGliL3R5cGVzL25vZGVzJztcbmV4cG9ydCB7IEFTVCB9O1xuZXhwb3J0IHsgaXNMaXRlcmFsLCBwcmludExpdGVyYWwgfSBmcm9tICcuL2xpYi91dGlscyc7XG4iXSwibmFtZXMiOlsiQVNULmlzTGl0ZXJhbCIsIkVudGl0eVBhcnNlciIsIm5hbWVkQ2hhclJlZnMiLCJFdmVudGVkVG9rZW5pemVyIiwiaXNMaXRlcmFsIiwiSEJTLmlzTGl0ZXJhbCIsImhhbmRsZWJhcnMucGFyc2UiLCJhc3NpZ24iXSwibWFwcGluZ3MiOiI7O2dCQXVFdUIsTUFDckI7V0FBTyxLQUFLLFNBQVMsbUJBQ2xCLEtBQUssU0FBUyx1QkFBdUIsS0FBSyxLQUFLLFNBQVM7O0FBd0Y3RCxtQkFBMEIsT0FDeEI7V0FBTyxDQUFDLEVBQUUsT0FBTyxVQUFVLFlBQVksTUFBTSxLQUFLLE1BQU07Ozs7Ozs7OztBQzNKMUQsdUJBQXVCLE1BQWlDLFFBQTJCLE1BQWlCLEtBQWUsS0FDakg7UUFBSSxDQUFDQSxVQUFjLE9BQU87ZUFDakIsVUFBVTs7O2NBSVg7O2dCQUVFLFVBQVU7Y0FDWixRQUFRLFVBQVU7aUJBQ2YsQ0FBQzthQUNMLFNBQVMsT0FOVDs7O0FBVVQsb0JBQW9CLE1BQW1CLFFBQWtDLE1BQXdCLFNBQXNCLFNBQStCLEtBQ3BKOztjQUNRO2NBQ0EsVUFBVTtnQkFDUixVQUFVO2NBQ1osUUFBUSxVQUFVO2lCQUNmLFdBQVc7aUJBQ1gsV0FBVzthQUNmLFNBQVMsT0FQVDs7O0FBV1QsOEJBQThCLE1BQW1CLFFBQTJCLE1BQWlCLEtBQzNGOztjQUNRO2NBQ0EsVUFBVTtnQkFDUixVQUFVO2NBQ1osUUFBUSxVQUFVO2FBQ25CLFNBQVMsT0FMVDs7O0FBU1Qsc0JBQXNCLE1BQTBCLFFBQTJCLE1BQWlCLFFBQWlCLEtBQzNHOztjQUNRO2NBQ0E7Z0JBQ0UsVUFBVTtjQUNaLFFBQVEsVUFBVTtnQkFDaEIsVUFBVTtlQUNYLEVBQUUsTUFBTSxPQUFPLE9BQU87YUFDeEIsU0FBUyxPQVBUOzs7QUFXVCxzQkFBc0IsT0FBZSxLQUNuQzs7Y0FDUTtlQUNDO2FBQ0YsU0FBUyxPQUhUOzs7QUFPVCw4QkFBOEIsT0FBZSxLQUMzQzs7Y0FDUTtlQUNDO2FBQ0YsU0FBUyxPQUhUOzs7QUFPVCxxQkFBcUIsT0FBaUQsS0FDcEU7O2NBQ1E7ZUFDQyxT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